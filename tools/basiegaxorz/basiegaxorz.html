<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
		<title>BasiEgaXorz - Sega Genesis BASIC Compiler - v1.37 Documentation</title>
	</head>
	<body bgcolor="#00ffcf" text="red" link="blue">
		<div align="center">
			<tt><b>BasiEgaXorz v1.37 Documentation</b></tt><br>
			<tt>Sega Genesis Tiny BASIC Compiler</tt><br>
			Author: DevSter (Joseph Norman)<br>
			http://devster.monkeeh.com<br>
		</div>
		<br>
		<div align="left">
			<i>&quot;Programming for the Sega Genesis is now as easy as jacking your grandmother's stash of porn&quot;<br>
			</i> - Bobo Gates<br>
			<br>
			For a possible newer version of this document, visit <a href="http://devster.monkeeh.com/sega/basiegaxorz/">http://devster.monkeeh.com/sega/basiegaxorz/</a><br>
			<b>Index</b><br>
			<ul>
				<li> <a href="#Introduction">Introduction</a>
				<li> <a href="#docsyntax">Document Syntax</a>
				<li> <a href="#Commands">BASIC Command Set</a> / <a href="#CommandsABC">In ABC Order</a>
				<ul>
					<li> <a href="#segacdcommands">Sega CD Specific Commands</a>
				</ul>
				<li> <a href="#Functions">BASIC Function Set</a> / <a href="#FunctionsABC">In ABC Order</a>
				<li> <a href="#Operators">Operators</a>
				<li> <a href="#Immediate">Immediate Operators</a>
				<li> <a href="#DataTypes">Data Types</a>
				<ul>
					<li> <a href="#arrays">Arrays and Multi-Dimensional Arrays</a>
				</ul>
				<li> <a href="#Argunerics">Argunerics</a>
				<li> <a href="#userfuncs">User-Defined Functions and Subroutines</a>
				<li> <a href="#advanced">Advanced Techniques</a>
				<ul>
					<li> <a href="#sinescosines">Sines/Cosines</a>
					<li> <a href="#interrupts">Interrupters</a>
					<li> <a href="#asm">Assembly Language in BASIC</a>
					<li> <a href="#userasmfuncs">User-Defined Assembly Language Functions and Subroutines</a>
					<li> <a href="#lowvideo">Low-Level Video Setup</a>
					<li> <a href="#sega32xcommands">Programming for the 32X Extension</a>
				</ul>
				<li> <a href="#segacdconv">Ono I live in teh Zimbabwe, USA cd's dun works on meh Sega CD!</a>
				<li> <a href="#Downloads"><b>Downloads</b> - YIPEE</a>
				<li> <a href="#History">History</a>
				<li> <a href="#Contacts">OMG This document is lame and the authot can't speak english, help me!</a>
				<li> <a href="#Bugs">Known Bugs</a>
				<li> <a href="#Contacts">Contacts</a>
				<li> <a href="#Credits">Credits</a>
				<li> <a href="#disclaimer">Disclaimer</a>
			</ul>
			<a name="Introduction"></a><b>Introduction</b><br>
				Basiegaxorz is a BASIC compiler for the Sega Genesis. This compiler is aimed for speed, so there are many (all) things that cannot be dynamic, everything is static. Line labels are supported too - yay.<br>
				<br>
			<a name="docsyntax"></a><b>Document Syntax</b><br>
				Expression - A listing of values. Ex: <tt>1+2+3=5, a=4, q&lt;&gt;4+5, etc.</tt><br>
				Statement, Command, Instruction - They are these: <a href="#commands">Commands</a>. <b>All commands have to have a space in front of them, unless they are followed by a label.</b><br>
				Label - A marking that marks the line. All labels cannot have a space in front of them!<br>
				Variable - Integer/String, you name it<br>
			<br>
				If arguments enclosed in &lt; &gt; in this document, then that argument is not optional. Optional arguments are enclosed in [ ].<br>
			<br>
			<a name="Commands"></a><b>Commands</b><br>
				Note: <b>All commands have to have a space/tab in front</b><br>
				<tt>
					<a href="#Command_PRINT">PRINT</a><br>
					<a href="#Command_CLS">CLS</a><br>
					<a href="#Command_GOTO">GOTO</a><br>
					<a href="#Command_FORNEXT">FOR....NEXT</a><br>
					<a href="#Command_DIM">DIM</a><br>
					<a href="#Command_IFELSEENDIF">IF....ELSE....ENDIF</a><br>
					<a href="#command_sleep">SLEEP</a><br>
					<a href="#command_data">DATA</a><br>
					<a href="#command_data">DATAINT</a><br>
					<a href="#command_data">DATALONG</a><br>
					<a href="#command_datafile">DATAFILE</a><br>
					<a href="#command_read">READ</a><br>
					<a href="#command_read">READINT</a><br>
					<a href="#command_read">READLONG</a><br>
					<a href="#command_reload">RELOAD</a><br>
					<a href="#command_reload">RESTORE</a><br>
					<a href="#command_while">WHILE....WEND</a><br>
					<a href="#command_end">END</a><br>
					<a href="#command_locate">LOCATE</a><br>
					<a href="#command_gosub">GOSUB</a><br>
					<a href="#command_return">RETURN</a><br>
					<a href="#command_on_event">ON &lt;EVENT&gt;</a><br>
					<a href="#command_enable">ENABLE</a><br>
					<a href="#command_disable">DISABLE</a><br>
					<a href="#command_shlink">SHLINK</a><br>
					<a href="#command_ink">INK</a><br>
					<a href="#command_loadtiles">LOADTILES</a><br>
					<a href="#command_drawtile">DRAWTILE</a><br>
					<a href="#command_drawtiles">DRAWTILES</a><br>
					<a href="#command_propsprite">PROPSPRITE</a><br>
					<a href="#command_movesprite">MOVESPRITE</a><br>
					<a href="#command_freesprite">FREESPRITE</a><br>
					<a href="#command_hidesprite">HIDESPRITE</a><br>
					<a href="#command_palette">PALETTE</a><br>
					<a href="#command_scroll">SCROLL</a><br>
					<a href="#command_shiftsprite">SHIFTSPRITE</a><br>
					<a href="#command_randomize">RANDOMIZE</a><br>
					<a href="#command_option">OPTION</a><br>
					<a href="#command_poke">POKE</a><br>
					<a href="#command_poke">POKEINT</a><br>
					<a href="#command_poke">POKELONG</a><br>
					<a href="#command_brighten">BRIGHTEN</a><br>
					<a href="#command_darken">DARKEN</a><br>
					<a href="#command_hblank">HBLANK</a><br>
					<a href="#command_palettes">PALETTES</a><br>
					<a href="#command_asm">ASM</a><br>
					<a href="#command_library">LIBRARY</a><br>
					<a href="#command_call">CALL</a><br>
					<a href="#command_psg">PSG</a><br>
					<a href="#command_psgvol">PSGVOL</a><br>
					<a href="#command_halt">HALT</a><br>
					<a href="#command_valt">VALT</a><br>
					<a href="#command_dalt">DALT</a><br>
					<a href="#command_trapcpu">TRAPCPU</a><br>
					<a href="#command_input">INPUT</a><br>
					<a href="#command_waitpadup">WAITPADUP</a><br>
					<a href="#command_bgcolor">BGCOLOR</a><br>
					<a href="#command_freeallsprites">FREEALLSPRITES</a><br>
					<a href="#command_settextplane">SETTEXTPLANE</a><br>
					<a href="#command_setgfxplane">SETGFXPLANE</a><br>
					<a href="#command_windowprop">WINDOWPROP</a><br>
					<a href="#command_puts">PUTS</a><br>
					<a href="#command_scroll2">SCROLL2</a><br>
					<a href="#command_setscrollmode">SETSCROLLMODE</a><br>
					<a href="#command_setscrollplane">SETSCROLLPLANE</a><br>
					<a href="#command_continue_while">CONTINUE WHILE</a><br>
					<a href="#command_continue_for">CONTINUE FOR</a><br>
					<a href="#command_exit_while">EXIT WHILE</a><br>
					<a href="#command_exit_for">EXIT FOR</a><br>
					<a href="#command_regmove">RegMove.B</a><br>
					<a href="#command_regmove">RegMove.W</a><br>
					<a href="#command_regmove">RegMove.L</a><br>
					<a href="#command_gets">Gets</a><br>
					<a href="#command_sleep2">Sleep2</a><br>
					<a href="#command_tvset">TVSet</a><br>
					<a href="#command_fake">Fake</a><br>
					<a href="#command_vdpramwrite">VdpRamWrite</a><br>
					<a href="#command_memcopy">MemCopy</a><br>
					<a href="#command_fasttilecopy">FastTileCopy</a><br>
					<a href="#command_drawtilesovr">DrawTilesOvr</a><br>
					<a href="#command_drawtilesinc">DrawTilesInc</a><br>
					<a href="#command_const">Const</a><br>
					<a href="#command_include">Include</a><br>
					<a href="#Command_write">Write</a><br>
					<a href="#Command_writeint">WriteInt</a><br>
					<a href="#Command_writelong">WriteLong</a><br>
					<a href="#Command_writep">WriteP</a><br>
					<a href="#Command_DIM_AT">DIM xxx AT xxx</a><br>
					<a href="#Command_vidmode">VidMode</a><br>
					<a href="#Command_loadfont">LoadFont</a><br>
					<a href="#Command_waitraster">WaitRaster</a><br>
					<a href="#Command_tileorg">TileOrg</a><br>
					<a href="#Command_vidata">VIData</a><br>
					<a href="#Command_vidata">VIDataInt</a><br>
					<a href="#Command_vidata">VIDataLong</a><br>
					<a href="#Command_vidatafile">VIDataFile</a><br>
					<br>
				</tt>
			<a name="CommandsABC"></a><b>Commands in Alphabetical Order</b><br>
				Note: <b>All commands have to have a space/tab in front</b><br>
				<tt>
					<a href="#command_asm">ASM</a><br>
					<a href="#command_bgcolor">BGCOLOR</a><br>
					<a href="#command_brighten">BRIGHTEN</a><br>
					<a href="#command_call">CALL</a><br>
					<a href="#Command_CLS">CLS</a><br>
					<a href="#command_const">CONST</a><br>
					<a href="#command_continue_while">CONTINUE WHILE</a><br>
					<a href="#command_continue_for">CONTINUE FOR</a><br>
					<a href="#command_dalt">DALT</a><br>
					<a href="#command_darken">DARKEN</a><br>
					<a href="#command_data">DATA</a><br>
					<a href="#command_datafile">DATAFILE</a><br>
					<a href="#command_data">DATAINT</a><br>
					<a href="#command_data">DATALONG</a><br>
					<a href="#Command_DIM">DIM</a><br>
					<a href="#Command_DIM_AT">DIM xxx AT xxx</a><br>
					<a href="#command_disable">DISABLE</a><br>
					<a href="#command_drawtile">DRAWTILE</a><br>
					<a href="#command_drawtiles">DRAWTILES</a><br>
					<a href="#command_drawtilesinc">DRAWTILESINC</a><br>
					<a href="#command_drawtilesovr">DRAWTILESOVR</a><br>
					<a href="#command_enable">ENABLE</a><br>
					<a href="#command_end">END</a><br>
					<a href="#command_exit_while">EXIT WHILE</a><br>
					<a href="#command_exit_for">EXIT FOR</a><br>
					<a href="#command_fake">FAKE</a><br>
					<a href="#command_fasttilecopy">FASTTILECOPY</a><br>
					<a href="#Command_FORNEXT">FOR....NEXT</a><br>
					<a href="#command_freeallsprites">FREEALLSPRITES</a><br>
					<a href="#command_freesprite">FREESPRITE</a><br>
					<a href="#command_gets">GETS</a><br>
					<a href="#command_global">GLOBAL</a><br>
					<a href="#command_gosub">GOSUB</a><br>
					<a href="#Command_GOTO">GOTO</a><br>
					<a href="#command_halt">HALT</a><br>
					<a href="#command_hblank">HBLANK</a><br>
					<a href="#command_hidesprite">HIDESPRITE</a><br>
					<a href="#Command_IFELSEENDIF">IF....ELSE....ENDIF</a><br>
					<a href="#command_include">INCLUDE</a><br>
					<a href="#command_ink">INK</a><br>
					<a href="#command_input">INPUT</a><br>
					<a href="#command_library">LIBRARY</a><br>
					<a href="#Command_LOADFONT">LOADFONT</a><br>
					<a href="#command_local">LOCAL</a><br>
					<a href="#command_locate">LOCATE</a><br>
					<a href="#command_loadtiles">LOADTILES</a><br>
					<a href="#command_memcopy">MEMCOPY</a><br>
					<a href="#command_movesprite">MOVESPRITE</a><br>
					<a href="#command_on_event">ON &lt;EVENT&gt;</a><br>
					<a href="#command_option">OPTION</a><br>
					<a href="#command_palette">PALETTE</a><br>
					<a href="#command_palettes">PALETTES</a><br>
					<a href="#command_poke">POKE</a><br>
					<a href="#command_poke">POKEINT</a><br>
					<a href="#command_poke">POKELONG</a><br>
					<a href="#Command_PRINT">PRINT</a><br>
					<a href="#command_propsprite">PROPSPRITE</a><br>
					<a href="#command_psg">PSG</a><br>
					<a href="#command_psgvol">PSGVOL</a><br>
					<a href="#command_puts">PUTS</a><br>
					<a href="#command_randomize">RANDOMIZE</a><br>
					<a href="#command_read">READ</a><br>
					<a href="#command_read">READINT</a><br>
					<a href="#command_read">READLONG</a><br>
					<a href="#command_regmove">REGMOVE.B</a><br>
					<a href="#command_regmove">REGMOVE.W</a><br>
					<a href="#command_regmove">REGMOVE.L</a><br>
					<a href="#command_reload">RELOAD</a><br>
					<a href="#command_reload">RESTORE</a><br>
					<a href="#command_return">RETURN</a><br>
					<a href="#command_scroll">SCROLL</a><br>
					<a href="#command_scroll2">SCROLL2</a><br>
					<a href="#command_setgfxplane">SETGFXPLANE</a><br>
					<a href="#command_setscrollmode">SETSCROLLMODE</a><br>
					<a href="#command_setscrollplane">SETSCROLLPLANE</a><br>
					<a href="#command_settextplane">SETTEXTPLANE</a><br>
					<a href="#command_shiftsprite">SHIFTSPRITE</a><br>
					<a href="#command_shlink">SHLINK</a><br>
					<a href="#command_sleep">SLEEP</a><br>
					<a href="#command_sleep2">SLEEP2</a><br>
					<a href="#Command_tileorg">TileOrg</a><br>
					<a href="#command_trapcpu">TRAPCPU</a><br>
					<a href="#command_tvset">TVSET</a><br>
					<a href="#command_valt">VALT</a><br>
					<a href="#command_vdpramwrite">VDPRAMWRITE</a><br>
					<a href="#Command_vidmode">VIDMODE</a><br>
					<a href="#Command_vidata">VIData</a><br>
					<a href="#Command_vidata">VIDataInt</a><br>
					<a href="#Command_vidata">VIDataLong</a><br>
					<a href="#Command_vidatafile">VIDataFile</a><br>
					<a href="#command_waitpadup">WAITPADUP</a><br>
					<a href="#Command_waitraster">WaitRaster</a><br>
					<a href="#command_while">WHILE....WEND</a><br>
					<a href="#command_windowprop">WINDOWPROP</a><br>
					<a href="#Command_write">WRITE</a><br>
					<a href="#Command_writeint">WRITEINT</a><br>
					<a href="#Command_writelong">WRITELONG</a><br>
					<a href="#Command_writep">WRITEP</a><br>
					<br>
				</tt>
				<a name="Command_PRINT"></a><i>Command_PRINT:</i><br>
					<i>Syntax:</i> <tt>Print &lt;Expression 1&gt;,&lt;Expression 2&gt;,......</tt><br>
					<i>Description:</i>Prints characters onto the screen. If a comma (,) is encountered, then a tab is placed. If a semi colon is encountered, then leading characters will be directly displayed appended to the last.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_CLS"></a><i>Command_CLS:</i><br>
					<i>Syntax:</i> <tt>Cls</tt><br>
					<i>Description: </i>Clears the frickin screen<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_GOTO"></a><i>Command_GOTO:</i><br>
					<i>Syntax:</i><tt>Goto &lt;Label&gt;</tt><br>
					<i>Description: </i><tt>Jumps to &lt;Label&gt;</tt><br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_FORNEXT"></a><i>Command_FOR:<br>Command_NEXT:</i><br>
					<i>Syntax:</i><br>
					<tt>For &lt;Integer Variable&gt; = &lt;Initial Expression&gt; to &lt;Final Expression&gt; [step &lt;Increment&gt;]<br>
					....Commands<br>
					....Commands<br>
					Next</tt><br>
					<i>Description: </i>Creates a loop by putting an initial value into &lt;Integer Variable&gt;, and then incrementing it by the step (is step &lt;increment&gt; is not specified, then 1 is used) until it reaches the value in &lt;Final Expression&gt;. Expressions are not calculated during run-time! Expressions are first calculated when the For command if first identified, and the value is then stored into memory. DO NOT use a Goto command to jump outside of the For....Next loop! Only use goto's to jump to a label inside the loop. For....Next counts are not checked, so if you forget a Next statement, you're program's gonna crash and burn.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_DIM"></a><i>Command_DIM:</i><br>
					<i>Syntax:</i> <tt>Dim &lt;Variable&gt;(Dimmensions) As &lt;Variable Type&gt; [* &lt;String Size&gt;], &lt;Variable&gt;(Dimmensions) As &lt;Variable Type&gt; [* &lt;String Size&gt;], ...</tt><br>
					<i>Description:</i> Dimensions a variable. There are three main data types: Integer, Long, and String. Integers are used for real numbers that are 16 bits wide (representing numbers -32768 to 65535). Integers have a <tt>&#37;</tt> suffix (ommiting the suffix on a variable makes the compiler assume the variable is integer though). Long variables are used for much bigger numbers, and always need to have an <tt>&#38;</tt> suffix! Strings are used to hold words, or a string of characters, and have to have a <tt>&#36;</tt> suffix. The size of strings can be specified by including the number of bytes of the string after <tt>STRING</tt> with a <tt>&#42;</tt>.<br>
					<br>
					Newer versions of BasiEgaXorz support multi-dimensional arrays. To specifiy dimensions for your array, enclose the dimensions of your array in between <tt>(</tt> and <tt>)</tt> after the variable name. For advanced users, there is another way to dimmension variables by specifying the address location of the variable. See <a href="#Command_DIM_AT"><tt>DIM xxx AT xxx</tt></a> for more details. Also see the <a href="#Command_GLOBAL"><tt>GLABAL</tt></a> and <a href="#Command_LOCAL"><tt>LOCAL</tt></a> commands on how to define variables in programs that contain user-defined subroutines or functions.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_DIM_AT"></a><i>Command_DIM_xxx_AT_xxx:</i><br>
					<i>Syntax:</i> <tt>Dim &lt;Variable&gt;(Dimmensions) As &lt;Variable Type&gt; [* &lt;String Size&gt;] At &ltLocation&gt;, &lt;Variable&gt;(Dimmensions) As &lt;Variable Type&gt; [* &lt;String Size&gt;] At &ltLocation&gt;, ...</tt><br>
					<i>Description:</i> Dimensions a variable, where the programmer specifies the location of the variable in memory. There are three main data types: Integer, Long, and String. Integers are 16 bits wide, long variables are 32-bit wide, and strings are blocks of 8-bit wide characters. The location of the variable can be represented by a constant number, specifying the absolute address of the variable within the 68k memory space (eg: 12345, or &h3039). The location can also be represented by a label in the source. The label will always point to data (eg: data defined by the commands DATA, DATAING, DATALONG, DATAFILE, etc). Label checking must be enabled in options first, prior to using labels. The location can also be specified with the &#64; character, or the &#42; asterik (both characters perform the same thing!), and using these symbols will point the location of your variable to the current location of the data counter, or to the next DATA statement.<br>
					<br>
					So why is it useful to specify locations of variables? One of the main advantages is to treat data within the ROM (or RAM, if compiling for the SEGA CD unit) like variables, refered to by &quot;Fake Variables&quot; by devster.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_IFELSEENDIF"></a><i>Command_IF:<br>Command_ELSE:<br>Command_ENDIF</i><br>
					<i>Syntax 1:</i><br>
					<tt>If &lt;Expression&gt; Then<br>
					....Instructions if true<br>
					....Instructions<br>
					EndIf</tt><br>
					<i>Syntax 2:</i><br>
					<tt>If &lt;Expression&gt; Then<br>
					....Instructions if true<br>
					....Instructions<br>
					Else<br>
					....Instructions if false<br>
					....Instructions<br>
					EndIf</tt><br>
					<i>Desctiption: </i>Performs a check on the expression. Blah blah, should be self explanitory, if not, check a basic tutorial. False=$00, True=Any other value. ElseIf is not supported.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_SLEEP"></a><i>Command_SLEEP:</i><br>
					<i>Syntax:</i> <tt>Sleep &lt;Integer Expression&gt;, [TVBLANK]</tt><br>
					<i>Description:</i> Pauses execution for (1/60) seconds, or ~16.67 ms. for every unit of the Expression. For example, using a value of 60 pauses execution for 1 second. If the TVBLANK keyword is present in the second argument, the sleep command ends at the begining of the verticle blank. By default, when TVBLANK is not present, the sleep command will end sleeping time at the begining of the displaying period. The extra extension is great for when you want to load tiles to VRAM right after the sleep command (tiles load faster because the VDP should be idle at this time).<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_data"></a><i>Command_DATA:</i><br>
					<i>Syntax:</i> <tt>Data &lt;Constant 1&gt;,&lt;Constant 2&gt;,........</tt><br>
					<i>Description:</i> Insets data into the basic program that can be read by command Read. Any data has to be byte-long (see DATAINT for 16-bit data, and DATALONG for 32-bit). Strings can be used in the DATA statement. The latest release of BasiEgaXorz no longer requires the user to zero-terminate any strings, and the newer compiler is backwards compatible with strings that were zero-terminated manually. An example string usage: <tt>Data &quot;Hello Data!&quot;</tt>. If a value greater than 255 is used (exceeding the byte-long data limit), the file will not compile.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_datafile"></a><i>Command_DATAFILE:</i><br>
					<i>Syntax:</i> <tt>Datafile &lt;Data File&gt;,[BIN]</tt><br>
					<i>Description:</i> Inserts data from an external file into the basic program that can be read by command Read. &lt;Data File&gt; has to be a file inside the compiler directory. When keyword BIN is used, the file will be included as a binary file. Example: <tt>Datafile Levels.dat,BIN</tt>. If BIN is left out, then the file will be included as a text. Proper text file syntax (same as assembler):<br>
					<tt>dc.b &lt;Byte Constants 1&gt;,&lt;Byte Constants 2&gt;......</tt><br>
					<tt>dc.w &lt;Word Constants 1&gt;,&lt;Word Constants 2&gt;......</tt><br>
					<tt>dc.l &lt;Long Constants 1&gt;,&lt;Long Constants 2&gt;......</tt><br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_read"></a>
					<i>Command_READ:</i><br>
					<i>Command_READINT:</i><br>
					<i>Command_READLONG:</i><br>
					<i>Syntax:</i><br>
					<tt>Read &lt;Variable 1&gt;,&lt;Variable 2&gt;,........</tt><br>
					<tt>ReadInt &lt;Variable 1&gt;,&lt;Variable 2&gt;,........</tt><br>
					<tt>ReadLong &lt;Variable 1&gt;,&lt;Variable 2&gt;,........</tt><br>
					<i>Description:</i> Reads data from the Data statements. If the Read command is used for the first time, then data will be read at the very first Data statement. After that, data will be read one after the other, increasing the data pointer, until a Reload command resets the pointer. If &lt;Variable&gt; is an integer, then data will be read, and the msb will be set to 0. If &lt;Variable&gt; is a string, then the data will be copied into a string one byte after the other until a NULL (0 - Zero) is reached.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_reload"></a>
					<i>Command_RELOAD:</i><br>
					<i>Command_RESTORE:</i><br>
					<i>Syntax:</i> <tt>Reload [Line Number/Label]</tt><br>
					<i>Description:</i> Resets the data pointer to the start of label. The label that Reload is directed to has to be directly in front of the data statement. For example: <tt>MyData: data &quot;Wassup&quot;,0,45</tt>. When [Label] is ommited, the data pointer is reset to the very first Data statement.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_while"></a><i>Command_WHILE:<br>Command_WEND:</i><br>
					<i>Syntax:</i><br>
					<tt>While &lt;Expression&gt;<br>
					....Instructions<br>
					....Instructions<br>
					Wend</tt><br>
					<i>Description:</i> Keeps on looping until &lt;Expression&gt; is false.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_end"></a><i>Command_END:</i><br>
					<i>Syntax:</i> <tt>End</tt><br>
					<i>Description:</i> Stops execution.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_locate"></a><i>Command_LOCATE:</i><br>
					<i>Syntax:</i> <tt>Locate &lt;Row&gt;,&lt;Column&gt;</tt><br>
					<i>Description:</i> Repositions the text cursor at &lt;Row&gt; and &lt;Column&gt;. The range for row is 0 to 25, and the range for column is 0 to 37. If &lt;Row&gt; or &lt;Column&gt; is omitted, then the corresponding cursor argument will not be changed. If the cursor is moved out of range, the program will not check for this, and text will end up being displayed out of the screen, unless the screen is scrolled. Permitted:<br>
					<tt>Locate 1,2 ' Will move cursor to row 1, column 2<br>
					Locate 3, ' Will move cursor to row 3, column unchanged<br>
					Locate ,5 ' Will move cursor to column 5, row unchanged</tt><br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_gosub"></a><i>Command_GOSUB:</i><br>
					<i>Syntax:</i> <tt>Gosub &lt;Label&gt;</tt><br>
					<i>Description:</i> Jumps program execution to &lt;Label&gt;. Program execution is returned to the instruction after the Gosub instruction after a <tt>Return </tt>command is found. Branches may be stretched to inifinite, depending on how much stack space is left.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_return"></a><i>Command_RETURN:</i><br>
					<i>Syntax:</i> <tt>Return</tt><br>
					<i>Description:</i> Returns program execution to the instruction after the last Gosub command.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_on_event"></a><i>Command_ON_EVENT:</i><br>
					<i>Syntax:</i> <tt>On &lt;Event&gt; Gosub &lt;Label&gt;</tt><br>
					<i>Description:</i> On the interruption of &lt;Event&gt;, the program will immediately change program execution to the specified &lt;Label&gt;. An event cannot be restarted if the program is executing in an event subroutine. An event subroutine may be ended by a <tt>Return </tt>command. The cursor location is always saved - if people don't like this, tell me and i'll remove that.<br>
					<i>List Of Events:</i><br>
					<tt>VBLANK - </tt>Verticle Blank Interrupter. Occurs 60 times per second.<br>
					<tt>HBLANK - </tt>Horizontal Blank Interrupter.<br>
					<tt>EXTINT - </tt>External Interrupter (found on controller ports). Read the ENABLE command for a better description of external hardware interrupters.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_enable"></a><i>Command_ENABLE:</i><br>
					<i>Syntax:</i> <tt>Enable &lt;Thing&gt;</tt><br>
					<i>Description:</i> Enables &lt;Thing&gt;.<br>
					<i>Values for &lt;Thing&gt;:</i><br>
					<tt>INTERRUPT VBLANK - </tt>Turns on the verticle blank interrupt. This command has to be executed in order for VBLANK events to be triggered. It is recommended that this instruction be placed anywhere after an <tt>On &lt;Event&gt; </tt>command.<br>
					<tt>INTERRUPT HBLANK - </tt>Turns on the horizontal blank interrupt. This command has to be executed in order for HBLANK events to be triggered. It is recommended that this instruction be placed anywhere after an <tt>On &lt;Event&gt; </tt>command.<br>
					<tt>INTERRUPT EXTERNAL, &lt;Joypad Number&gt; - </tt>Turns on the external interrupter. External interrupters occur on the controller/extension ports. The external interrupter is triggered when a Logic LOW on the TH pin of the controller port is pulsed. When the interrupter occurs, the HV counter is latched (eg: for making an easy light-gun interface). Since the HV counter is being latched, I believe you won't be able to read the HV counter during normal program execution (outside the interupter) like you would for doing rasters. When the counter is latched, that means it will stay a constant value, and will not update itself with the TV trace. To re-enable HV counter real time reading, disable this interupter. &lt;Joypad Number&gt; is a number between 0 and 2 (0=Player 1, 1=Player 2, 2=Extension port found on old Segas).<br>
					<tt>SCREEN - </tt>Turns on all screen displaying.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_disable"></a><i>Command_DISABLE:</i><br>
					<i>Syntax:</i> <tt>Disable &lt;Thing&gt;</tt><br>
					<i>Description:</i> Disables &lt;Thing&gt;.<br>
					<i>Values for &lt;Thing&gt;:</i><br>
					<tt>INTERRUPT VBLANK - </tt>Turn off the verticle blank interrupt. See <tt>On &lt;Event&gt; </tt>to make use of this.<br>
					<tt>INTERRUPT HBLANK - </tt>Turns off the horizontal blank interrupt. This command has to be executed in order for HBLANK events to be triggered. It is recommended that this instruction be placed anywhere after an <tt>On &lt;Event&gt; </tt>command.<br>
					<tt>INTERRUPT EXTERNAL, &lt;Joypad Number&gt; - </tt>Turns off any external interrupters from the controller/extension ports. You still need to specify the Joypad number in order to properly make the joypad function like it use to. The HV counter is no longer being latched after this command, so now you can read the HV counter.<br>
					<tt>SCREEN - </tt>Turns off all screen displaying. Blanking signals are still sent to the TV, and the backdrop color is the only component drawn during the active display period. Note: Verticle and Horizontal interrupters and status signals are disabled when the screen is off, so the command <tt>Sleep</tt> and other status signal dependent routines will freeze.<br>
					<tt>WINDOW - </tt>Resets the window.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_shlink"></a><i>Command_SHLINK:</i><br>
					<i>Syntax:</i> <tt>Shlink &lt;Label&gt;</tt><br>
					<i>Description:</i> Jumps program execution to &lt;Label&gt;. It is only recommended that this command only be used in an event subroutines to jump immediatly to &lt;Label&gt;. Normally, you cannot use <tt>Goto </tt>to jump outside of an event subroutine. I thought this command might be useful for things where many instructions are being executed in the main program loop, where there is no room to read the joypad, and therefore needs to use an event to check the joypads, and jump out of the main program loop at a certain condition. Also, this resets the stack space, so if you had subroutines called with Gosub in the main program loop, then these subroutines will be immediatly killed, and you cannot use Return to jump to the instruction right after the relevant Gosub instruction.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_return"></a><i>Command_INK:</i><br>
					<i>Syntax:</i> <tt>Ink &lt;Pattern&gt;</tt><br>
					<i>Description:</i> Changes the color of the drawing text to &lt;Pattern&gt;. The range is from 0 to 3. The default colors for &lt;Pattern&gt; on reset are:<br>
					<tt>0 - White<br>
					1 - Cyan/Baby blue<br>
					2 - Green<br>
					3 - Purple/Magenta<br></tt>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_loadtiles"></a><i>Command_LOADTILES:</i><br>
					<i>Syntax:</i> <tt>LoadTiles &lt;Tile Data Label&gt;, &lt;Tiles Count&gt;, &lt;Tile Destination in Video Memory&gt;, [Tile Source Offset from Label]</tt><br>
					<i>Description:</i> Loads tiles into video memory. &lt;Tile Data Label&gt; points to the Label that tile data will be loaded from. This has to be a label with a corresponding data/datafile statement. &lt;Tiles Count&gt; is the number of tiles that will be loaded. One unit of &lt;Tile Count&gt; is equal to one 8*8 tile. &lt;Tile Destination in Video Memory&gt; points to the destination tile number that these tiles will be copied to. One unit of &lt;Tile Destination.....&gt; is equal to one 8*8 tile, and the destination starts at 0 and end at 1343. So, the video memory can hold 1344 simultaneous tiles (43008 bytes of VRAM). Tile numbers 0 to 255 is the text font. [Tile Source Offset from Label] is an optional argument, where it starts copying tiles after so and so tiles in the &lt;Tile Data Label&gt;. On unit of &lt;Tile Data Label&gt; is equal to one 8*8 tile. For example, if [Tile Source Offset from Label] is twelve, then tiles will be loaded twelve tiles after the data label. If this argument is ommited, then a value of 0 is used.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_drawtile"></a><i>Command_DRAWTILE:</i><br>
					<i>Syntax:</i> <tt>DrawTile &lt;tile vram offset&gt;, &lt;x&gt;, &lt;y&gt;</tt><br>
					<i>Description:</i> Draws one tile on the screen at &lt;x&gt; and &lt;y&gt;. One unit of X or Y is equal to one 8*8 cell. X and Y start at (0,0), and that is the very upper left part of the screen - FYI: Text starts drawing at (1,1). &lt;Tile VRAM Offset&gt; is the tile number that will be drawn. One unit of this is equal to one 8*8 tile.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_drawtiles"></a><i>Command_DRAWTILES:</i><br>
					<i>Syntax:</i> <tt>DrawTiles &lt;label&gt;, &lt;tile vram offset&gt;, &lt;x&gt;, &lt;y&gt;, &lt;width&gt;, &lt;height&gt;, [Data Label Offset]</tt><br>
					<i>Description:</i> Draws one or more tiles on the screen at &lt;X&gt; and &lt;Y&gt; that is &lt;Width&gt; and &lt;Height&gt; big. One unit of X, Y, Width, or Height is equal to one 8*8 cell. X and Y start at (0,0), and that is the very upper left part of the screen. &lt;Tile VRAM Offset&gt; is the tile number that will be drawn. One unit of this is equal to one 8*8 tile. &lt;Label&gt; is a data label were the drawing map is located. The data has to be in byte format (using <tt>Data</tt>). The command draws the map in the order from left to right, up to down.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_propsprite"></a><i>Command_PROPSPRITE:</i><br>
					<i>Syntax:</i> <tt>PropSprite &lt;sprite number&gt;, &lt;tile vram offset&gt;, &lt;palette&gt;</tt><br>
					<i>Description:</i> Sets the drawing tile, and color palette of a sprite. &lt;sprite number&gt; is the sprite handle recieved from <tt>AddSprite()</tt>. [tile vram offset] is the tile that is shown by the sprite, in video memory. One unit of [tile vram offset] is one 8*8 cell. [palette] is the palette number to designate the sprite for color generation. [palette] is in the range from 0 to 3.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_movesprite"></a><i>Command_MOVESPRITE:</i><br>
					<i>Syntax:</i> <tt>MoveSprite &lt;sprite number&gt;, &lt;x&gt;, &lt;y&gt;</tt><br>
					<i>Description:</i> Changes the locations of a sprite. &lt;sprite number&gt; is the sprite handle recieved from <tt>AddSprite()</tt>. X and Y are the locations to move the sprite to. One unit of X and Y are equal to one pixel. Sprites are shown on the screen starting at (128,128). eg: <tt>MoveSprite MySprite%,200,250</tt> will move the sprite to (200,250), but the sprite will actually appear at (72,122) on the screen. Any value less than 128 is used to hide the sprite.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_freesprite"></a><i>Command_FREESPRITE:</i><br>
					<i>Syntax:</i> <tt>FreeSprite &lt;sprite number&gt;</tt><br>
					<i>Description:</i> Destroys the sprite, and frees up that handle to be used for another sprite. &lt;sprite number&gt; is the sprite handle recieved from <tt>AddSprite()</tt>.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_hidesprite"></a><i>Command_HIDESPRITE:</i><br>
					<i>Syntax:</i> <tt>HideSprite &lt;sprite number&gt;</tt><br>
					<i>Description:</i> Hides the sprite from the active display area. It actually relocates the sprite to (0,0) for actual coordinates, or (-128,-128) for coordinates relative to the actual display. Sprite is not destroyed, unlike the <tt>FreeSprite</tt> command.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_palette"></a><i>Command_PALETTE:</i><br>
					<i>Syntax:</i> <tt>Palette &lt;RGB Code&gt;, &lt;palette number&gt;, &lt;color number&gt;</tt><br>
					<i>Description:</i> Changes the color make-up of one palette entry. The Genesis has a total of 4 palettes, and each palette holds 16 colors (each tile is made up of 1 pixel=4 bits). &lt;palette number&gt; is the palette number in the range 0 to 3. &lt;color number&gt; is the color entry inside the palette, in a range from 0 to 15. Color entry #0 for each palette is transparent for sprites. You can use the function <tt>RGB()</tt> to get the &lt;RGB Code&gt; using the 3 different color components: red, green, blue.<br>
					<i>RGB Code Bit Format</i><br>
					<tt>MSB ooooBBBoGGGoRRRo LSB</tt><br>
					o's = Value of 0<br>
					RRR = Red value, 0 to 7<br>
					GGG = Green value, 0 to 7<br>
					BBB = Blue value, 0 to 7<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_scroll"></a><i>Command_SCROLL:</i><br>
					<i>Syntax:</i> <tt>Scroll &lt;UP/DOWN/LEFT/RIGHT&gt;, [Quantity], [Entry]</tt><br>
					<i>Description:</i> Scrolls a background plane. &lt;UP/DOWN/LEFT/RIGHT&gt; is the direction to scroll in. [Quantity] is the displacement to shift the screen corresponding to its direction. [entry] is the scroll entry. If the scroll mode for a direction is HSCROLL_OVERALL or VSCROLL_OVERALL, then [entry] can be ommited. If the scroll mode for a direction is HSCROLL_CELL then [entry] specifies which horizontal cell will be scrolled, where one unit of [entry] equals 8 horizontal lines (in pixels).If the scroll mode for a direction is HSCROLL_LINE then entry specifies which horizontal line will be scrolled, where one unit of [entry] equals one pixel high line. If the scroll mode for a direction is VSCROLL_2CELL then entry specifies which verticle line will be scrolled, where one unit of [entry] equals a width of two cells (two cells equals 16 pixels). The <tt>Scroll</tt> command does not scroll sprites along with the background plane. Sprite will have to be shifted manually, if desired.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_shiftsprite"></a><i>Command_SHIFTSPRITE:</i><br>
					<i>Syntax:</i> <tt>ShiftSprite &lt;sprite number&gt;, &lt;dx&gt;, &lt;dy&gt;</tt><br>
					<i>Description:</i> Relatively moves the sprite (a shift, or scroll). The command does not set the sprite's X and Y coordinates, compared to the command <tt>MoveSprite</tt>. &lt;sprite number&gt; is the sprite handle recieved from <tt>AddSprite()</tt>. &lt;dx&gt; and &lt;dy&gt; are the change in X and Y to move the sprite. Example directions: dx=-1 and dy=0 will move the sprite left by one pixel, dx=2 and dy=5 will move the sprite right by 2 pixels and down by 5 pixels, dx=-10 and dy=-1 will move the sprite left by 10 pixels and up by 1 pixel.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_randomize"></a><i>Command_RANDOMIZE:</i><br>
					<i>Syntax:</i> <tt>Randomize [seed]</tt><br>
					<i>Description:</i> Changes the seed for the random number generator. Changing the seed is essential for making sure that each number being coming out of the random number generator is unique. Having the same seed throughout the program will yield the same pattern of numbers coming out of the random number generator. Ignoring a value for seed will just substitute the video's HV counter for the seed. A good way to make use of getting pure random numbers is to place a <tt>Randomize</tt> statement right after a joypad routine has detected a key.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_option"></a><i>Command_OPTION:</i><br>
					<i>Syntax:</i> <tt>Option &lt;setting&gt;, &lt;Value&gt;</tt><br>
					<i>Description:</i> Changes compilation options<br>
					<table border="1" cellpadding="0" cellspacing="2">
						<tr>
							<td width="170">&lt;Setting&gt;</td>
							<td width="120">&lt;Value&gt;</td>
							<td>Description</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">DEDICATED SEGACD</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Tells the compiler to compiler only for the Sega CD</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">TITLE</td>
							<td nowrap width="120" valign="top">A Title</td>
							<td valign="top">Sets the title for a Cartidge game</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">STRING SIZE</td>
							<td nowrap width="120" valign="top">Size</td>
							<td valign="top">Changes the default string size. The default string size is 128</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">SEGACD</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Overrides settings in the Options dialog, and compiled the program to a Sega Boot CD</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">SEGACD PROGRAM</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Overrides settings in the Options dialog, and compiled the program to a Sega CD Program. Sega CD Programs can be used for programs on a Sega Boot CD. They can also be used on MoD's <a href="http://www.retrodev.com/transfer.html">Transfer Suite</a>.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">CARTRIDGE</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Overrides settings in the Options dialog, and compiled the program to a ROM cartridge</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">REORGCODE</td>
							<td nowrap width="120" valign="top">Address</td>
							<td valign="top">Sets the compiler base address for Sega CD programs</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">REORGVARS</td>
							<td nowrap width="120" valign="top">Address</td>
							<td valign="top">Sets the compiler base address to place variables</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">EXTERNAL SRAM</td>
							<td nowrap width="120" valign="top">&lt;Start Address&gt;, &lt;Size&gt;, [EVEN/ODD/BOTH]</td>
							<td valign="top">Allocates external SRAM space for external variables. All external variables begin with ext_</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">FONTFOREENTRY</td>
							<td nowrap width="120" valign="top">&lt;Palette entry 0-15&gt;</td>
							<td valign="top">Changes the palette entry that text printing commands will use to draw the foreground of text, or font. The default palette entry is entry 1.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">FONTBACKENTRY</td>
							<td nowrap width="120" valign="top">&lt;Palette entry 0-15&gt;</td>
							<td valign="top">Changes the palette entry that text printing commands will use to draw the background of text, or font. The default palette entry for the background is entry 0 / transparent.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">EXPLICIT</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">When <tt>OPTION EXPLICIT</tt> is defined in the program, all variables will have to be declared. Failure to declare a variable before using it will show an error. This option will overwrite the option set in the options panel.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">CASESENSE</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Turns off case sensitivity checking of variables and labels.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">CASESENSEOFF</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Turns off case sensitivity checking of variables and labels. Same exact thing as <tt>OPTION CASESENSE</tt>.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">CASESENSEON</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Turns on case sensitivity checking of variables and labels. Variables and labels that have different cases (same spelling, but different capital/lowercase characters) will be recognized different by the compiler.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">RUNSCRIPTS</td>
							<td nowrap width="120" valign="top">xxx</td>
							<td valign="top">Not implemented in public releases of basiegaxorz yet.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">TEXTPRIORITY</td>
							<td nowrap width="120" valign="top">HIGH / LOW</td>
							<td valign="top">Sets the tile priority of text printed using the text printing commands. Use as simply: <tt>OPTION TEXTPRIORITY HIGH</tt>, or <tt>OPTION TEXTPRIORITY LOW</tt>. This command makes no difference in distinguishing priorities between tile planes A and B, but sprites that are shown over high priority text will be shown behind the text.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">GLOBALVARS</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Defines all variables in a program to be global. This option will even overwrite variables defined by the <tt>LOCAL</tt> command.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">TEXTHEIGHT</td>
							<td nowrap width="120" valign="top">&lt;Number&gt;</td>
							<td valign="top">Sets the maximum height limits for text printing commands to print on the screen. If text goes past the bottem of the screen, a vram DMA routine will shift all characters up by 1. The default value used in BasiEgaXorz is 26.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">TEXTWIDTH</td>
							<td nowrap width="120" valign="top">&lt;Number&gt;</td>
							<td valign="top">Sets the maximum width limits for text printing commands to print on the screen. If text goes past the right of the screen, text will continue to be printed, starting on the next line, at the first column. The default width value used in BasiEgaXorz is 38.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">TEXTSTART</td>
							<td nowrap width="120" valign="top">&lt;Row&gt;, &lt;Column&gt;</td>
							<td valign="top">Sets where the text displaying routines will start drawing text. The default row is 1 and the defualt column is 1.</td>
						</tr>
						<tr>
							<td nowrap width="170" valign="top">NOLOADFONT</td>
							<td nowrap width="120" valign="top">-</td>
							<td valign="top">Forces the startup code to not load the system font at startup.</td>
						</tr>

					</table>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_poke"></a><i>Command_POKE:<br>Command_POKEINT:<br>Command_POKELONG:</i><br>
					<i>Syntax:</i><br>
					<tt>Poke &lt;CPU Address&gt;, &lt;Data (Byte)&gt;</tt><br>
					<tt>PokeInt &lt;CPU Address&gt;, &lt;Data (Word)&gt;</tt><br>
					<tt>PokeLong &lt;CPU Address&gt;, &lt;Data (Long)&gt;</tt><br>
					<i>Description:</i> Sets the contents of &lt;CPU Address&gt; to &lt;Data&gt;. Used for more advanced tricks.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_brighten"></a><i>Command_BRIGHTEN:</i><br>
					<i>Syntax:</i> <tt>Brighten &lt;palette&gt;, &lt;color entry&gt;, &lt;increment&gt;, &lt;delay&gt;, &lt;count&gt;</tt><br>
					<i>Description:</i> Increases the color intensity of a single color entry. &lt;palette&gt; and &lt;color entry&gt; define which color entry to brighten. &lt;increment&gt; is a color code. &lt;increment&gt; is what the routine uses to increase the intensity. For example, if the color code of a defined entry was gray (0x040404), and the brighten command is used with an increment of 0x000002, then the resulting color after one loop will be 0x040406. &lt;delay&gt; is the number of 16.67 ms to delay each time the entry is incremented (Same delay as the <tt>Sleep</tt> command). &lt;count&gt; is the number of times to brighten the entry. One unit of &lt;count&gt; is equal to one increment. <br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_darken"></a><i>Command_DARKEN:</i><br>
					<i>Syntax:</i> <tt>Darken &lt;palette&gt;, &lt;color entry&gt;, &lt;decrement&gt;, &lt;delay&gt;, &lt;count&gt;</tt><br>
					<i>Description:</i> Decreases the color intensity of a single color entry. &lt;palette&gt; and &lt;color entry&gt; define which color entry to brighten. &lt;decrement&gt; is a color code. &lt;decrement&gt; is what the routine uses to decrease the intensity. For example, if the color code of a defined entry was gray (0x040404), and the darken command is used with an decrement of 0x000002, then the resulting color after one loop will be 0x040406. &lt;delay&gt; is the number of 16.67 ms to delay each time the entry is decremented (Same delay as the <tt>Sleep</tt> command). &lt;count&gt; is the number of times to brighten the entry. One unit of &lt;count&gt; is equal to one decrement. <br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_hblank"></a><i>Command_HBLANK:</i><br>
					<i>Syntax:</i> <tt>HBlank &lt;number of scanlines&gt;</tt><br>
					<i>Description:</i> Used for determining the scanline count for which a horizontal blank interrupter occurs. &lt;number of scanlines&gt; is a number 0 to 222 determining how many scanlines +1 will be counted until an interrupter is triggered, for one screen. For example, if the number of scanlines were set to 24, then the horizontal interrupt will occur every 25 scanlines, or 8 times during the the active display period (TC is composed of 224 lines, 224/25=8, to be conservative). Each horizontal blank is approximately 14.6 usec long, and each scan line is approximately 64.0 us long. A value of 0 is not recommended, unless you don't utilize the verticle blank interrupter (a value of 0 means a horizontal interrupter will occur every line). On the real system, the verticle blank interrupter will never occur if used with a value of 0.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_palettes"></a><i>Command_PALETTES:</i><br>
					<i>Syntax:</i> <tt>Palettes &lt;data label&gt;, &lt;palette number&gt;, &lt;color nentry&gt;, &lt;count&gt;, [Data Label Offset]</tt><br>
					<i>Description:</i> Loads more than one color into color RAM. &lt;data label&gt; is a data label that marks were the data starts. The data statements must use the command DataInt for defining color codes. See the <tt>Palette</tt> command for details on color codes. You can't use the <tt>RGB</tt> function in data statements, so all color codes need to be constants. &lt;palette number&gt; is the palette number, ranging from 0 to 3. &lt;color nentry&gt; is the color entry within the color palette, ranging from 0 to 15. &lt;count&gt; is the number of color entries to load. One unit of &lt;count&gt; equals one color entry.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_asm"></a><i>Command_ASM:</i><br>
					<i>Syntax:</i> <tt>Asm &quot;&lt;Instruction&gt; [operand 1], [operand 2]&quot;</tt><br>
					<i>Description:</i> Inserts assembly code directly into the assembler output of the BASIC file. The expression must be in quotes, and the expression cannot be in a variable/string.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_library"></a><i>Command_LIBRARY:</i><br>
					<i>Syntax:</i> <tt>Library &lt;filename&gt;</tt><br>
					<i>Description:</i> Includes an assembly library into compilation. The functions in the library will have to be called by command <tt>Call</tt>, or function <tt>Call()</tt>/<tt>Call&()</tt>. These calling commands/functions will jump directly to the label that you specified for your routine. Assembler errors will be displayed whenever an error occurs, so you can fix. See the corresponding call command/function for details on the requirements of assembly routines. The file must be located in the directory <tt>slibrary</tt>, inside the directory of the compiler's executable (eg: C:\basiegaxorz\slibrary, if the compiler is located in basiegaxorz).<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_call"></a><i>Command_CALL:</i><br>
					<i>Syntax:</i> <tt>Call &lt;routine label&gt;, [argument 1], [argument 2],....., [argument n]</tt><br>
					<i>Description:</i> Calls a user defined assembly routine. &lt;routine label&gt; is the label of the routine that you defined. The label can be anything, except for some keywords already taken by the compiler's own code. All routines must end with a <tt>rts</tt> instruction to continue execution.<br>
					<i>Arguments:</i> The arguments passed to the routine are stored onto the heap. The begining of the heap is pointed to with register <tt>A5</tt>. The heap works from lower addresses to higher addresses. Arguments are pushed onto the stack from left to right on the line where the <tt>Call</tt> command is being executed. If an argument is an integer, or long, the value of the expression is stored onto the stack as a 4 byte long number. If an argument is a string, the whole solved string is pushed onto the heap, from left to right, and is terminated with a null (0). If the address ended by pushing a string is an odd number, then an extra null (0) is added. After an argument is pushed onto the heap, the nest argument is pushed onto the stack right after the last one.<br>
					<i>Registers:</i> All data registers <tt>D0-D7</tt> can freely be changed by the routine. Address registers <tt>A0-A4</tt> can be freely used also. <tt>A5</tt> is reserved to hold the heap pointer. <tt>A6</tt> is reserved to hold the data pointer. <tt>A7</tt> is reserved to hold the stack pointer.<br>
					<i>Implementing BASIC Labels:</i> All BASIC labels and number lines all begin with <tt>__LABEL_</tt>, and are followed by the label specified.<br>
					<i>Implementing BASIC Variables:</i> All BASIC integers begin with <tt>__INTEGER_</tt>, and are followed by the variable name specified. All BASIC longs begin with <tt>__LONG_</tt>, and are followed by the variable name specified. All BASIC strings begin with <tt>__STRING_</tt>, and are followed by the variable name specified.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_psg"></a><i>Command_PSG:</i><br>
					<i>Syntax:</i> <tt>Psg &lt;Channel&gt;, &lt;Data&gt;</tt><br>
					<i>Description:</i> Plays a frequency, or changes noise parameters for a PSG sound channel. &lt;Channel&gt; is the channel, ranging from 0 to 3. Channels 0 to 2 are the tone channels, and channel 3 is the noise generator. &lt;Data&gt; is a 10-bit frequency for a tone channel. If the channel is the noise generator, then &lt;Data&gt; has these parameters:<br>
					<i>Noise Generator</i><br>
					<tt>MSB: 0 0 0 0 0 FB NF1 NF0 :LSB</tt>
					<table border="0" cellpadding="0" cellspacing="5">
						<tr><td><i>FB</i></td><td><i>Noise type</i></td></tr>
						<tr><td>0</td><td>Periodic (like low-frequency tone)</td></tr>
						<tr><td>1</td><td>White (hiss)</td></tr>
					</table>
					<table border="0" cellpadding="0" cellspacing="5">
						<tr><td><i>NF1</i></td>	<td><i>NF0</i></td>	<td><i>Noise Generator Clock Source</i>			</td></tr>
						<tr><td>0</td>		<td>0</td>		<td>Clock/2 [Higher pitch, &quot;less coarse&quot;]	</td></tr>
						<tr><td>0</td>		<td>1</td>		<td>Clock/4						</td></tr>
						<tr><td>1</td>		<td>0</td>		<td>Clock/8 [Lower pitch, &quot;more coarse&quot;]	</td></tr>
						<tr><td>1</td>		<td>1</td>		<td>Tone Generator #3					</td></tr>
					</table>
					<i>Notes to Frequency to PSG Conversion Table</i>
					<table border="0" cellspacing="1" width="100%">
						<tr>
							<td width="16%" colstart="1" align="right">	<b>Note</b></td>
							<td width="16%" colstart="3" align="center">	<b>PSG</b></td>
							<td width="17%" colstart="4">			<b>Hertz</b></td>
							<td width="17%" colstart="5" align="right">	<b>Note</b></td>
							<td width="17%" colstart="7" align="center">	<b>PSG</b></td>
							<td width="17%" colstart="8">			<b>Hertz</b></td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>A 3</b></td>
							<td width="16%" colstart="3" align="center">7</td>
							<td width="17%" colstart="4">110.00</td>
							<td width="17%" colstart="5" align="right"><b>B 5</b></td>
							<td width="17%" colstart="7" align="center">798</td>
							<td width="17%" colstart="8">493.88</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>A# 3</b></td>
							<td width="16%" colstart="3" align="center">64</td>
							<td width="17%" colstart="4">116.54</td>
							<td width="17%" colstart="5" align="right"><b>C 6</b></td>
							<td width="17%" colstart="7" align="center">810</td>
							<td width="17%" colstart="8">523.25</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>B 3</b></td>
							<td width="16%" colstart="3" align="center">118</td>
							<td width="17%" colstart="4">123.47</td>
							<td width="17%" colstart="5" align="right"><b>C# 6</b></td>
							<td width="17%" colstart="7" align="center">822</td>
							<td width="17%" colstart="8">554.37</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>C 4</b></td>
							<td width="16%" colstart="3" align="center">169</td>
							<td width="17%" colstart="4">130.81</td>
							<td width="17%" colstart="5" align="right"><b>D 6</b></td>
							<td width="17%" colstart="7" align="center">834</td>
							<td width="17%" colstart="8">587.33</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>C# 4</b></td>
							<td width="16%" colstart="3" align="center">217</td>
							<td width="17%" colstart="4">138.59</td>
							<td width="17%" colstart="5" align="right"><b>D# 6</b></td>
							<td width="17%" colstart="7" align="center">844</td>
							<td width="17%" colstart="8">622.25</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>D 4</b></td>
							<td width="16%" colstart="3" align="center">262</td>
							<td width="17%" colstart="4">146.83</td>
							<td width="17%" colstart="5" align="right"><b>E 6</b></td>
							<td width="17%" colstart="7" align="center">854</td>
							<td width="17%" colstart="8">659.26</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>D# 4</b></td>
							<td width="16%" colstart="3" align="center">305</td>
							<td width="17%" colstart="4">155.56</td>
							<td width="17%" colstart="5" align="right"><b>F 6</b></td>
							<td width="17%" colstart="7" align="center">864</td>
							<td width="17%" colstart="8">698.46</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>E 4</b></td>
							<td width="16%" colstart="3" align="center">345</td>
							<td width="17%" colstart="4">164.81</td>
							<td width="17%" colstart="5" align="right"><b>F# 6</b></td>
							<td width="17%" colstart="7" align="center">873</td>
							<td width="17%" colstart="8">739.99</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>F 4</b></td>
							<td width="16%" colstart="3" align="center">383</td>
							<td width="17%" colstart="4">174.61</td>
							<td width="17%" colstart="5" align="right"><b>G 6</b></td>
							<td width="17%" colstart="7" align="center">881</td>
							<td width="17%" colstart="8">783.99</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>F# 4</b></td>
							<td width="16%" colstart="3" align="center">419</td>
							<td width="17%" colstart="4">184.99</td>
							<td width="17%" colstart="5" align="right"><b>G# 6</b></td>
							<td width="17%" colstart="7" align="center">889</td>
							<td width="17%" colstart="8">830.61</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>G 4</b></td>
							<td width="16%" colstart="3" align="center">453</td>
							<td width="17%" colstart="4">195.99</td>
							<td width="17%" colstart="5" align="right"><b>A 6</b></td>
							<td width="17%" colstart="7" align="center">897</td>
							<td width="17%" colstart="8">880.00</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>G# 4</b></td>
							<td width="16%" colstart="3" align="center">485</td>
							<td width="17%" colstart="4">207.65</td>
							<td width="17%" colstart="5" align="right"><b>A# 6</b></td>
							<td width="17%" colstart="7" align="center">904</td>
							<td width="17%" colstart="8">932.32</td>
							</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>A 4</b></td>
							<td width="16%" colstart="3" align="center">516</td>
							<td width="17%" colstart="4">220.00</td>
							<td width="17%" colstart="5" align="right"><b>B 6</b></td>
							<td width="17%" colstart="7" align="center">911</td>
							<td width="17%" colstart="8">987.77</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>A# 4</b></td>
							<td width="16%" colstart="3" align="center">544</td>
							<td width="17%" colstart="4">233.08</td>
							<td width="17%" colstart="5" align="right"><b>C 7</b></td>
							<td width="17%" colstart="7" align="center">917</td>
							<td width="17%" colstart="8">1046.5</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>B 4</b></td>
							<td width="16%" colstart="3" align="center">571</td>
							<td width="17%" colstart="4">246.94</td>
							<td width="17%" colstart="5" align="right"><b>C# 7</b></td>
							<td width="17%" colstart="7" align="center">923</td>
							<td width="17%" colstart="8">1108.7</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>C 5</b></td>
							<td width="16%" colstart="3" align="center">596</td>
							<td width="17%" colstart="4">261.63</td>
							<td width="17%" colstart="5" align="right"><b>D 7</b></td>
							<td width="17%" colstart="7" align="center">929</td>
							<td width="17%" colstart="8">1174.7</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>C# 5</b></td>
							<td width="16%" colstart="3" align="center">620</td>
							<td width="17%" colstart="4">277.18</td>
							<td width="17%" colstart="5" align="right"><b>D# 7</b></td>
							<td width="17%" colstart="7" align="center">934</td>
							<td width="17%" colstart="8">1244.5</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>D 5</b></td>
							<td width="16%" colstart="3" align="center">643</td>
							<td width="17%" colstart="4">293.66</td>
							<td width="17%" colstart="5" align="right"><b>E 7</b></td>
							<td width="17%" colstart="7" align="center">939</td>
							<td width="17%" colstart="8">1318.5</td>
						</tr>
						<tr>
							<td width="16%" colstart="1" align="right"><b>D# 5</b></td>
							<td width="16%" colstart="3" align="center">664</td>
							<td width="17%" colstart="4">311.13</td>
							<td width="17%" colstart="5" align="right"><b>F 7</b></td>
							<td width="17%" colstart="7" align="center">944</td>
							<td width="17%" colstart="8">1396.9</td>
						</tr>
						<tr>
							<td width="17%" colstart="5" align="right"><b>E 5</b></td>
							<td width="17%" colstart="7" align="center">685</td>
							<td width="17%" colstart="8">329.63</td>
							<td width="17%" colstart="5" align="right"><b>F# 7</b></td>
							<td width="17%" colstart="7" align="center">948</td>
							<td width="17%" colstart="8">1480.0</td>
						</tr>
						<tr>
							<td width="17%" colstart="5" align="right"><b>F 5</b></td>
							<td width="17%" colstart="7" align="center">704</td>
							<td width="17%" colstart="8">349.23</td>
							<td width="17%" colstart="5" align="right"><b>G 7</b></td>
							<td width="17%" colstart="7" align="center">953</td>
							<td width="17%" colstart="8">1568.0</td>
						</tr>
						<tr>
							<td width="17%" colstart="5" align="right"><b>F# 5</b></td>
							<td width="17%" colstart="7" align="center">722</td>
							<td width="17%" colstart="8">369.99</td>
							<td width="17%" colstart="5" align="right"><b>G# 7</b></td>
							<td width="17%" colstart="7" align="center">957</td>
							<td width="17%" colstart="8">1661.2</td>
						</tr>
						<tr>
							<td width="17%" colstart="5" align="right"><b>G 5</b></td>
							<td width="17%" colstart="7" align="center">739</td>
							<td width="17%" colstart="8">391.99</td>
							<td width="17%" colstart="5" align="right"><b>A 7</b></td>
							<td width="17%" colstart="7" align="center">960</td>
							<td width="17%" colstart="8">1760.0</td>
						</tr>
						<tr>
							<td width="17%" colstart="5" align="right"><b>G# 5</b></td>
							<td width="17%" colstart="7" align="center">755</td>
							<td width="17%" colstart="8">415.31</td>
							<td width="17%" colstart="5" align="right"><b>A# 7</b></td>
							<td width="17%" colstart="7" align="center">964</td>
							<td width="17%" colstart="8">1864.7</td>
						</tr>
						<tr>
							<td width="17%" colstart="5" align="right"><b>A 5</b></td>
							<td width="17%" colstart="7" align="center">770</td>
							<td width="17%" colstart="8">440.00</td>
							<td width="17%" colstart="5" align="right"><b>B 7</b></td>
							<td width="17%" colstart="7" align="center">967</td>
							<td width="17%" colstart="8">1975.5</td>
						</tr>
						<tr>
							<td width="17%" colstart="5" align="right"><b>A# 5</b></td>
							<td width="17%" colstart="7" align="center">784</td>
							<td width="17%" colstart="8">466.16</td>
							<td width="17%" colstart="5" align="right"><b>C 8</b></td>
							<td width="17%" colstart="7" align="center">971</td>
							<td width="17%" colstart="8">2093.0</td>
						</tr>
					</table>
					<i>Middle C = 261.63Hz = <b>C 5</b></i><br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_psgvol"></a><i>Command_PSGVOL:</i><br>
					<i>Syntax:</i> <tt>PsgVol &lt;Channel&gt;, &lt;Volume&gt;</tt><br>
					<i>Description:</i> Changes the volume of a PSG sound channel. &lt;Channel&gt; is the channel, ranging from 0 to 3. &lt;Volume&gt; is the volume, ranging from 0 to 7, were 0 is mute, and 7 is the maximum volume.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_halt"></a><i>Command_HALT:</i><br>
					<i>Syntax:</i> <tt>Halt</tt><br>
					<i>Description:</i> Pauses execution until the TV enters the horizontal blanking period. Interrupters are still executed during the pause period.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_valt"></a><i>Command_VALT:</i><br>
					<i>Syntax:</i> <tt>Valt</tt><br>
					<i>Description:</i> Pauses execution until the TV enters the verticle blanking period. Interrupters are still executed during the pause period.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_dalt"></a><i>Command_DALT:</i><br>
					<i>Syntax:</i> <tt>Dalt</tt><br>
					<i>Description:</i> Pauses execution until the TV enters the active display region of the screen. Interrupters are still executed during the pause period.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_trapcpu"></a><i>Command_TRAPCPU:</i><br>
					<i>Syntax:</i> <tt>TrapCPU</tt><br>
					<i>Description:</i> Breaks execution at that line. Almost like a breakpoint, but not all that equivalent. When a breakpoint is encountered, all execution is stopped, and text is displayed at the bottem indicating that a breakpoint has occured, the line at which the <tt>TrapCPU</tt> command was placed, and a query to either return to normal program execution, or to restart execution. Pressing button START on joystick #1 will return execution. Pressing button C will reset execution.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_input"></a><i>Command_INPUT:</i><br>
					<i>Syntax:</i> <tt>Input [Optional String Text],&lt;Variable Name&gt;,...</tt><br>
					<i>Description:</i> Gets user input. Input is stored onto the string, or integer, or long variable. The Inputting proceedure follows the &quot;password style&quot; way of entering values from a controller. The UP and DOWN buttons change the character. The A button places that character onto the line. The B button erases the last character from the line. The C button switches between upper and lower case letters. The START button ends user input, and takes whatever was entered in. Interrupts are still executed during the time the user is entering stuff. If [Optional String Text] is used, then a question mark will not appear automatically in the prompt. If [Optional String Text] is ommited, then a variable can just be placed in immediately to act as the input variable.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_waitpadup"></a><i>Command_WAITPADUP:</i><br>
					<i>Syntax:</i> <tt>WaitPadUp &lt;Controller Number&gt;</tt><br>
					<i>Description:</i> Pauses execution until all the buttons on a controller are released. &lt;Controller Number&gt; is the controller number, starting with 0. A value of 0 is actually joystick #1, a value of 1 is joystick #2, and a value of 2 is the extension on Genesis model 1's. Interrupters are still executed during the pause period.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_bgcolor"></a><i>Command_BGCOLOR:</i><br>
					<i>Syntax:</i> <tt>BGColor &lt;Palette&gt;, &lt;Entry&gt;</tt><br>
					<i>Description:</i> Sets the back drop color palette entry for the screen. The back drop color is the color that is placed behind all planes where entry 0 is used. Eg: the back drop color is the background color for text. &lt;Palette&gt;, &lt;Entry&gt; specify which color palette entry to use. &lt;Palette&gt; has a range from 0 to 3 and &lt;Entry&gt; has a range from 0 to 15.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_freeallsprites"></a><i>Command_FREEALLSPRITES:</i><br>
					<i>Syntax:</i> <tt>FreeAllSprites</tt><br>
					<i>Description:</i> Clears all displayed sprites, and resets all sprite handles to nothing, like when the Sega goes through a hardware reset.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_settextplane"></a><i>Command_SETTEXTPLANE:</i><br>
					<i>Syntax:</i> <tt>SetTextPlane &lt;SCROLL_A/SCROLL_B/WINDOW&gt;</tt><br>
					<i>Description:</i> Sets the drawing plane for all ASCII text commands. The SCROLL_B plane has the lowest display priority of all planes. Sprites will always have the highest priority. SCROLL_A will overlap SCROLL_B. The window plane then overlaps SCROLL_A.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_setgfxplane"></a><i>Command_SETGFXPLANE:</i><br>
					<i>Syntax:</i> <tt>SetGFXPlane &lt;SCROLL_A/SCROLL_B/WINDOW&gt;</tt><br>
					<i>Description:</i> Sets the drawing plane for all tile drawing commands. The commands included are: <tt>DrawTile, DrawTiles</tt>. The SCROLL_B plane has the lowest display priority of all planes. Sprites will always have the highest priority. SCROLL_A will overlap SCROLL_B. The window plane then overlaps SCROLL_A.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_windowprop"></a><i>Command_WINDOWPROP:</i><br>
					<i>Syntax:</i> <tt>WindowProp &lt;LEFT/RIGHT&gt;, &lt;UP/DOWN&gt;, &lt;Width&gt;, &lt;Height&gt;</tt><br>
					<i>Description:</i> Displays the window, and sets its view properties. &lt;LEFT/RIGHT&gt; determines if the window will be alligned to the left side of the screen, or the right. &lt;UP/DOWN&gt; determines if the window will be alligned to the top of the screen, or the bottem. &lt;Width&gt; and &lt;Height&gt; designate how large the window should be. The window overlaps anything over scroll A and scroll B.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_puts"></a><i>Command_PUTS:</i><br>
					<i>Syntax:</i> <tt>Puts &lt;Screen Position&gt;, &lt;Expression 1&gt;;&lt;Expression 2&gt;,......</tt><br>
					<i>Description:</i>Prints characters onto the screen at &lt;Screen Position&gt;. Unlike the <tt>Print</tt> command, Puts doesn't use the Cursor for text position, and it ignores any tabs and carriage returns, and display wrapping, and display scrolling. &lt;Screen Position&gt; is the location to place the text. One unit of &lt;Screen Position&gt; equals one 8x8 cell. 64 units of &lt;Screen Position&gt; equals one horizontal line. When &lt;Screen Position&gt; is divided by 64, the remainder of that number determines which verticle cell the text will be positioned on. Here's the formula: <tt>&lt;Screen Position&gt;=Row*64+Column</tt>. If a semi colon is encountered between text expressions, then leading characters will be directly displayed appended to the last. The <tt>PUTS</tt> command uses the same text plane as the <tt>PRINT</tt> command, or any other text command. The display plane can be changed by using the command <tt>SETTEXTPLANE</tt>.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_scroll2"></a><i>Command_SCROLL2:</i><br>
					<i>Syntax:</i> <tt>Scroll2 &lt;UP/DOWN/LEFT/RIGHT&gt;, [Value], [Entry]</tt><br>
					<i>Description:</i> Scrolls a background plane. &lt;UP/DOWN/LEFT/RIGHT&gt; is the direction to scroll to. [Value] is the number to set the scroll quantity to. As [Value] increases, scrolling shifts to the left, or upwards. As [Value] becomes negative, scrolling shifts to the right, or downwards. If [Value] is ommitted, then the scrolling value becomes 0. [entry] is the scroll entry. If the scroll mode for a direction is HSCROLL_OVERALL or VSCROLL_OVERALL, then [entry] can be ommited. If the scroll mode for a direction is HSCROLL_CELL then [entry] specifies which horizontal cell will be scrolled, where one unit of [entry] equals 8 horizontal lines (in pixels).If the scroll mode for a direction is HSCROLL_LINE then entry specifies which horizontal line will be scrolled, where one unit of [entry] equals one pixel high line. If the scroll mode for a direction is VSCROLL_2CELL then entry specifies which verticle line will be scrolled, where one unit of [entry] equals a width of two cells (two cells equals 16 pixels). The <tt>Scroll</tt> command does not scroll sprites along with the background plane. Sprite will have to be shifted manually, if desired.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_setscrollmode"></a><i>Command_SETSCROLLMODE:</i><br>
					<i>Syntax:</i> <tt>SetScrollMode &lt;HSCROLL_OVERALL/HSCROLL_CELL/HSCROLL_LINE&gt;, &lt;VSCROLL_OVERALL/VSCROLL_2CELL&gt;</tt><br>
					<i>Description:</i> Sets the scrolling mode. If HSCROLL_OVERALL is used, then when the screen is scrolled horizontally, the entire plane is scrolled. If HSCROLL_CELL is used, then when the screen is scrolled horizontally, 1 horizontal cell gets scrolled. If HSCROLL_LINE is used, then when the screen is scrolled horizontally, 1 horizontal line gets scrolled. If VSCROLL_OVERALL is used, then when the screen is scrolled verticle, the entire plane is scrolled verticle. If VSCROLL_2CELL is used, then when the screen is scrolled verticle, 2 verticle cell gets scrolled. Note: when VSCROLL_2CELL is used, both planes SCROLL_A and SCROLL_B will be scrolled together.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_setscrollplane"></a><i>Command_SETSCROLLPLANE:</i><br>
					<i>Syntax:</i> <tt>SetScrollMode &lt;SCROLL_A/SCROLL_B&gt;</tt><br>
					<i>Description:</i> Sets the plane to scroll.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_continue_while"></a><i>Command_CONTINUEWHILE:</i><br>
					<i>Syntax:</i> <tt>Continue While</tt><br>
					<i>Description:</i> Interrupts the normal flow of execution in a while loop. The Continue While statement skips all the following statements in the body loop and triggers the next itteration of the loop. This technique can be of use within complex loops where you might wish to skip the next loop iteration from various locations.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_continue_for"></a><i>Command_CONTINUEFOR:</i><br>
					<i>Syntax:</i> <tt>Continue For</tt><br>
					<i>Description:</i> Interrupts the normal flow of execution in a for loop. The Continue For statement skips all the following statements in the body loop and triggers the next itteration of the loop. This technique can be of use within complex loops where you might wish to skip the next loop iteration from various locations.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_continue_doloop"></a><i>Command_CONTINUEDOLOOP:</i><br>
					<i>Syntax:</i> <br>
						<tt>Continue Do</tt><br>
						<tt>Continue Loop</tt><br>
					<i>Description:</i> Interrupts the normal flow of execution in a Do/Loop loop. The Continue For statement skips all the following statements in the body loop and triggers the next itteration of the loop. This technique can be of use within complex loops where you might wish to skip the next loop iteration from various locations.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_exit_while"></a><i>Command_EXITWHILE:</i><br>
					<i>Syntax:</i> <tt>Exit While</tt><br>
					<i>Description:</i> Interrupts and terminates a While loop immediately. This technique can be of use within complex loops where you might wish to skip the next loop iteration in various locations.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_exit_for"></a><i>Command_EXITFOR:</i><br>
					<i>Syntax:</i> <tt>Exit For</tt><br>
					<i>Description:</i> Interrupts and terminates a For loop immediately. This technique can be of use within complex loops where you might wish to skip the next loop iteration in various locations.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_exit_doloop"></a><i>Command_EXITDOLOOP:</i><br>
					<i>Syntax:</i> <br>
						<tt>Exit Do</tt><br>
						<tt>Exit Loop</tt><br>
					<i>Description:</i> Interrupts and terminates a Do/Loop loop immediately. This technique can be of use within complex loops where you might wish to skip the next loop iteration in various locations.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_regmove"></a><i>Command_REGMOVE.B:<br>Command_REGMOVE.W:<br>Command_REGMOVE.L:</i><br>
					<i>Syntax:</i> <tt>RegMove.X &lt;Source&gt;,&lt;Destination&gt;</tt><br>
					<i>Description:</i> Copies a 68k register into a BASIC variable, for use with a lower level language. The register names are D0....D7, and A0....A7. The source or destination can either be a 68k register or a BASIC expression, but cannot be both at any same time. Like the assembly Move instruction, the RegMove.X statement will not truncate any registers if the size of the data transfter is a byte of word.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_gets"></a><i>Command_GETS:</i><br>
					<i>Syntax:</i> <tt>Gets &lt;Variable&gt;</tt><br>
					<i>Description:</i> Gets user input and stores it in a variable. The gets command is cheap compared to the Input command, no sprite for a cursor, no carriage returns, no output text, etc., so its really crude entering values. Interrupts are still executed during the time the user is entering stuff.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_sleep2"></a><i>Command_SLEEP2:</i><br>
					<i>Syntax:</i> <tt>Sleep2 &lt;Integer Expression&gt;, [TVBLANK]</tt><br>
					<i>Description:</i> Pauses execution for one horizontal blank for every unit of the Expression. The period for the horizontal blank is approximately 64 uSec (One Sec is 1,000,000 uSec!!!). If the TVBLANK keyword is present in the second argument, the sleep command ends at the begining of the horizontal blank (Good for color rasters). By default, when TVBLANK is not present, the sleep command will end sleeping time at the begining of the displaying period.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_incasm"></a><i>Command_INCASM:</i><br>
					<i>Syntax:</i> <tt>IncAsm &lt;filename&gt;</tt><br>
					<i>Description:</i> Includes an assembly library into compilation. The functions in the library will have to be called by command <tt>Call</tt>, or function <tt>Call()</tt>/<tt>Call&()</tt>. These calling commands/functions will jump directly to the label that you specified for your routine. Assembler errors will be displayed whenever an error occurs, so you can fix. See the corresponding call command/function for details on the requirements of assembly routines.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_tvset"></a><i>Command_TVSET:</i><br>
					<i>Syntax:</i> <tt>TVSet &lt;TV Type&gt;</tt><br>
					<i>Description:</i> Sets NTSC 60hz or PAL 50hz video drawing mode. By default, all programs start out as NTSC. If &lt;TV Type&gt; is 0, NTSC is selected. If &lt;TV Type&gt; is 1, PAL is selected<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_fake"></a><i>Command_FAKE:</i><br>
					<i>Syntax:</i> <tt>Fake &lt;Fake Data Label&gt;,&lt;Variable&gt;</tt><br>
					<i>Description:</i> Converts a variable address into a data label. &lt;Fake Data Label&gt; is a new data label to create that will point to the variable. &lt;Variable&gt; is the variable. If the variable is an array, an element must be defined first. This command is useful for loading tiles that reside in variable, where the <tt>LoadTiles</tt> command requires a data label. It is also good for interpreting data inside variable without direct variable usage.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_vdpramwrite"></a><i>Command_VDPRAMWRITE:</i><br>
					<i>Syntax:</i> <tt>VdpRamWrite &lt;RAM Address&gt;,&lt;Data&gt;</tt><br>
					<i>Description:</i> Writes data into VRAM. &lt;RAM Address&gt; is the address (has to be EVEN), it can be integer, or long. &lt;Data&gt; is the data to write to that address. VRAM is 64 kilobytes big, and writes to the VRAM are all 2 bytes long. ODD addresses cannot be accessed, and individual byte writes are not permitted.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_memcopy"></a><i>Command_MEMCOPY:</i><br>
					<i>Syntax:</i> <tt>MemCopy &lt;Source Data Label&gt;,&lt;Destination Data Label&gt;,&lt;Size&gt;</tt><br>
					<i>Description:</i> Copies memory from &lt;Source Data Label&gt; to &lt;Destination Data Label&gt;. &lt;Size&gt; is the number of bytes that will be copied. Copying speed is dependent upon EVEN, or ODD addresses (EVEN being the fastest), and the size of the block to copy.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_fasttilecopy"></a><i>Command_FASTTILECOPY:</i><br>
					<i>Syntax:</i> <tt>FastTileCopy &lt;Source Data Label&gt;,&lt;Destination Data Label&gt;,&lt;Number of tiles&gt;</tt><br>
					<i>Description:</i> Copies memory from &lt;Source Data Label&gt; to &lt;Destination Data Label&gt;. Almost the same as <tt>MemCopy</tt>, but uses faster copying code. &lt;Number of tiles&gt; is the number of 8*8 tiles that will be copied. One unit of &lt;Number of tiles&gt; is equal to one 8*8 tile, or 32 bytes.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_drawtilesovr"></a><i>Command_DRAWTILESOVR:</i><br>
					<i>Syntax:</i> <tt>DrawTilesOvr &lt;label&gt;, &lt;tile vram offset&gt;, &lt;x&gt;, &lt;y&gt;, &lt;width&gt;, &lt;height&gt;, [Data Label Offset]</tt><br>
					<i>Description:</i> Just like the <tt>DrawTiles</tt> command, except this command does not overwrite any tile that has a source tile of 0. Example: If a game map has the number 0 in it, and DrawTilesOvr was used to draw this map, the 0 will not be written to VRAM, and the tiles drawn before will reamin unchanged. See the <a href="#Command_drawtiles">DRAWTILES</a> command for arguments, and details.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_drawtilesinc"></a><i>Command_DRAWTILESINC:</i><br>
					<i>Syntax:</i> <tt>DrawTilesInc &lt;tile vram offset&gt;, &lt;x&gt;, &lt;y&gt;, &lt;width&gt;, &lt;height&gt;</tt><br>
					<i>Description:</i> Draws one or more tiles on the screen at &lt;X&gt; and &lt;Y&gt; that is &lt;Width&gt; and &lt;Height&gt; big. One unit of X, Y, Width, or Height is equal to one 8*8 cell. X and Y start at (0,0), and that is the very upper left part of the screen. &lt;Tile VRAM Offset&gt; is the tile number that will be drawn. One unit of this is equal to one 8*8 tile. Just like the <tt>DrawTiles</tt> command, but this one doesn't use any data labels. Instead, it starts drawing using the data from &lt;tile vram offset&gt;, and incrementing it by 1 for each tile drawn. Drawing starts from the left, then goes to the right. When it reaches the maximum width, the command will then move the drawing cursor down, and then start drawing from the left to right again.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_drawtilesinc2"></a><i>Command_DRAWTILESINC2:</i><br>
					<i>Syntax:</i> <tt>DrawTilesInc &lt;tile vram offset&gt;, &lt;x&gt;, &lt;y&gt;, &lt;width&gt;, &lt;height&gt;</tt><br>
					<i>Description:</i> Draws one or more tiles on the screen at &lt;X&gt; and &lt;Y&gt; that is &lt;Width&gt; and &lt;Height&gt; big. One unit of X, Y, Width, or Height is equal to one 8*8 cell. X and Y start at (0,0), and that is the very upper left part of the screen. &lt;Tile VRAM Offset&gt; is the tile number that will be drawn. One unit of this is equal to one 8*8 tile. Just like the <tt>DrawTiles</tt> command, but this one doesn't use any data labels. Instead, it starts drawing using the data from &lt;tile vram offset&gt;, and incrementing it by 1 for each tile drawn. Drawing starts from the top, then draws going down. When it reaches the maximum height, the command will then move the drawing cursor right, and then start drawing top to bottem again.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_const"></a><i>Command_CONST:</i><br>
					<i>Syntax:</i> <tt>Const #Constant Name=Constant Value</tt><br>
					<i>Description:</i> Defines a constant. All constants begin with a #. A constant must first be defined before it can be used.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_include"></a><i>Command_INCLUDE:</i><br>
					<i>Syntax:</i> <tt>Include &lt;File Name&gt;</tt><br>
					<i>Description:</i> Includes another BASIC source code into the source code. Includes cannot be nested, and this command is still very buggy, and will be buggy for a long time.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_write"></a><i>Command_Write:</i><br>
					<i>Syntax:</i> <tt>Write &lt;Expression 1&gt;,&lt;Expression 2&gt;,........</tt><br>
					<i>Description:</i> Like the read command, but does the opposite. It writes data to Data commands. The data that is written is only temporary, when the unit is turned off, the data is lost. This command can be used by both a Sega CD Master Program, and a regular Sega CD Program.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_writeint"></a><i>Command_WriteInt:</i><br>
					<i>Syntax:</i> <tt>WriteInt &lt;Expression 1&gt;,&lt;Expression 2&gt;,........</tt><br>
					<i>Description:</i> Like the read command, but does the opposite. It writes data to Data commands. The data that is written is only temporary, when the unit is turned off, the data is lost. This command can be used by both a Sega CD Master Program, and a regular Sega CD Program.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_writelong"></a><i>Command_WriteLong:</i><br>
					<i>Syntax:</i> <tt>WriteLong &lt;Expression 1&gt;,&lt;Expression 2&gt;,........</tt><br>
					<i>Description:</i> Like the read command, but does the opposite. It writes data to Data commands. The data that is written is only temporary, when the unit is turned off, the data is lost. This command can be used by both a Sega CD Master Program, and a regular Sega CD Program.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_writep"></a><i>Command_WriteP:</i><br>
					<i>Syntax:</i> <tt>WriteP &lt;Variable Name&gt;, &lt;Value to write into variable&gt;</tt><br>
					<i>Description:</i> Writes data into ram that is 8-bits in size. WriteP (stands for Write-Peripheral) is mostly used to external battery bakup ram that is provided on the game cartridge. WriteP handles data differently compared to normal storage operations (eg: <tt>ext_a = 1234 ' Won't work in external ram unless the ram is 16-bits</tt>). The first argument specifies the variable to write into. If this variable is not declared, and is not an array, then the compiler will declare the variable automatically. The second parameter is the actual value to write into the external ram space.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_LOCAL"></a><i>Command_LOCAL:</i><br>
					<i>Syntax:</i> <tt>Local &lt;Variable&gt;(Dimmensions) As &lt;Variable Type&gt; [* &lt;String Size&gt;] [At &lt;Location&gt;], &lt;Variable&gt;(Dimmensions) As &lt;Variable Type&gt; [* &lt;String Size&gt;] [At &lt;Location&gt;], ...</tt><br>
					<i>Descrition:</i> Dimensions a local variable. The variable declared can either be local to the main loop, or for the current function, depending on where the statement is placed. Everything else is the same as the <a href="command_DIM">DIM</a> statement. The purpose of this command is to deny access to local variables outside the scope where it was defined.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_GLOBAL"></a><i>Command_GLOBAL:</i><br>
					<i>Syntax:</i> <tt>Global &lt;Variable&gt;(Dimmensions) As &lt;Variable Type&gt; [* &lt;String Size&gt;] [At &lt;Location&gt;], &lt;Variable&gt;(Dimmensions) As &lt;Variable Type&gt; [* &lt;String Size&gt;] [At &lt;Location&gt;], ...</tt><br>
					<i>Descrition:</i> Dimensions a global variable. The variable declared will be able to be accessed anywhere in your program, even if it is out of the scope of the current procedure. These is also an option (see the <a href="command_OPTION">OPTION</a> command for details) to make all variables declared with <tt>DIM</tt> global.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_FONTPAL"></a><i>Command_FONTPAL:</i><br>
					<i>Syntax:</i> <tt>FontPal [Foreground Color RGB], [Background Color RGB]</tt><br>
					<i>Description:</i> This command automatically changes the color palette entries for text displayed with <tt>PRINT</tt> for you without having to calculate which color entry you want to change. The programmer doesn't need to know which color entry the font is using in palette memory (CRAM) in order to change the colors of the font. This command is totally different from the <tt>COLOR</tt> command, as in this command can change the actual RGB values. When changing the RGB color though, you risk changing the color of all the text on the screen (all the text that is printed with the same color).<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_DOLOOP"></a><i>Command_DOLOOP:</i><br>
					<i>Syntax:</i> <pre>
	Do [While / Until] &lt;expression&gt;
		... Instructions
		... Instructions
	Loop [While / Until] &lt;expression&gt;</pre>
					<i>Description:</i> Similiar to Visual Basic's Do....Loop, this loop structure will keep repeating through the loop until a certain condition is reached. The programmer needs to place the keywords <tt>While</tt>, or <tt>Until</tt> after either <tt>Do</tt> or <tt>Loop</tt> to tell the compiler when to check for conditions. Use the <tt>While</tt> keyword to keep the loop repeating when the supplied expression is true. Use the <tt>Until</tt> keyword to stop the loop from repeating when the supplied expression becomes true. When the check condition is placed after <tt>DO</tt>, the compiler will place code to check for conditions at the begining of the loop. When the condition is places after <tt>LOOP</tt>, then the condition will be checked at the end of the loop. The loop can be exitted immediately using the command: <tt>EXIT LOOP</tt>. The command <tt>CONTINUE LOOP</tt> can be used also.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_SELECTCASE"></a><i>Command_SELECTCASE:</i><br>
					<i>Syntax:</i> <pre>
	Select Case &lt;Variable&gt;
		Case &lt;Integer/Long Number&gt;:
			... Instructions
			[Exit Select]
		Case &lt;Integer/Long Number&gt;:
			... Instructions
			[Exit Select]
		[Case Else:]
			[... Instructions]
			[Exit Select]
	End Select</pre>
					<i>Description:</i> The select case instruction will jump to specific portions of your code (cases) based on the value inside the variable specified. The Select Case usage, and operation is totally different compared to other basic languages. Select Case in BaisEgaXorz uses a table to jump to certain locations, so only integer and long values can be used for the variable. Also, values inside your cases have to be in ascending order. If the programmer omits a value from the case (there is a gap in between cases), then when Select Case is executed, the program will jump to the last lowest case value. If the value is below the lowest case value, then the program will jump to the <tt>Case Else</tt> condition. Refer to examples on proper ways to use Select Case. Using Select Case in BasiegaXorz is very advanced, but when used correctly, it can be very rewarding because it can speed your program up very fast (compared to using 100 different If...Then statements). Whenever possible, don't use Select Case very often because of it's complexities, which can create bugs for many users.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_VIDMODE"></a><i>Command_VIDMODE:</i><br>
					<i>Syntax:</i> <tt>VidMode &lt;Mode Keyword&gt;, ...</tt><br>
					<i>Description:</i> Changes the drawing mode of Sega's VDP (video display processor). Valid video modes are: <tt>DOUBLEINTERLACE, INTERLACE, VID32CELL, VID40CELL</tt>. Modes can be mixed around, or not even used at all.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_LOADFONT"></a><i>Command_LOADFONT:</i><br>
					<i>Syntax:</i> <tt>LoadFont [Font Data Label], &lt;Number of tiles to load&gt;, &lt;Start Tile Number&gt;</tt><br>
					<i>Description:</i> Replaces the internal font in VDP vram with a user-specified font. The font is always in a 1-bit format, or each bit will represent one pixel. A bit value of 0 will draw the background color, and a value of 1 will draw the foreground. If the data label pointing to the font is ommitted, the default font from ROM will be loaded (the default font).<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="Command_WAITRASTER"></a><i>Command_WAITRASTER:</i><br>
					<i>Syntax:</i> <tt>&lt;Scan line number&gt;</tt><br>
					<i>Description:</i> Pauses the program until the TV draws the scan-line specified by the programmer. Scan-line is an integer value. Using <tt>TVBLANK</tt> as the scan-line value will start execution exactly at the horizontal blank of the next scan-line.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_vidata"></a><i>Command_VIDATA:</i><br>
					<i>Syntax:</i> <tt>ViData &lt;Constant 1&gt;,&lt;Constant 2&gt;,........</tt><br>
					<i>Description:</i> Inserts VRAM Initialization data into the basic program. This data cannot be read out like the DATA command. Any data going here is written directly to the VRAM at the startup of the program. Use the <tt>TILEORG</tt> command to change the tile address. Any data has to be byte-long (see DATAINT for 16-bit data, and DATALONG for 32-bit). VRAM initialization data is particularly useful for RAM games to reduce the executable size. VRAM initialization data also works for other compilations (ROM based games, Sega CD, etc) too.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_vidatafile"></a><i>Command_VIDATAFILE:</i><br>
					<i>Syntax:</i> <tt>ViDatafile &lt;Data File&gt;,[BIN]</tt><br>
					<i>Description:</i> Inserts data from an external file into VRAM Initialization space. &lt;Data File&gt; has to be a file inside the compiler directory. When keyword BIN is used, the file will be included as a binary file. Example: <tt>Datafile Levels.dat,BIN</tt>. If BIN is left out, then the file will be included as a text. Proper text file syntax (same as assembler):<br>
					<tt>dc.b &lt;Byte Constants 1&gt;,&lt;Byte Constants 2&gt;......</tt><br>
					<tt>dc.w &lt;Word Constants 1&gt;,&lt;Word Constants 2&gt;......</tt><br>
					<tt>dc.l &lt;Long Constants 1&gt;,&lt;Long Constants 2&gt;......</tt><br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="command_tileorg"></a><i>Command_TILEORG:</i><br>
					<i>Syntax:</i> <tt>TileOrg &lt;Tile Number&gt;</tt><br>
					<i>Description:</i> Changes the current tile number for the <tt>VIDATA, VIDATAINT, VIDATALONG, VIDATAFILE</tt> instructions. The tile number is a number from 0 to 2047. The system font occupies tiles 0 - 255. To disable the loading of the system font, use the <tt>OPTION NoLoadFont</tt> option.<br>
					<a href="#CommandsABC">Back to the ABC Command Index</a><br>
					<br>
			<a name="segacdcommands"></a><b>Sega CD Specific Commands</b><br>
				Note: <b>All commands have to have a space/tab in front.</b> Sega CD specific commands can only be used on projects that are compiled as a Sega CD boot ISO, or a Sega CD Program (except for some commands).<br>
				<tt>
					<a href="#Command_cdplay">CDPLAY</a><br>
					<a href="#Command_cdplay2">CDPLAY2</a><br>
					<a href="#Command_cdstop">CDSTOP</a><br>
					<a href="#Command_addscd">ADDSCD</a><br>
					<a href="#Command_loadscd">LOADSCD</a><br>
					<a href="#command_loadscdv">LOADSCD (For Loading VRAM Data)</a><br>
					<a href="#command_loadscda">LOADSCD (For Loading Data Into Variables)</a><br>
					<a href="#command_loadscdp">LOADSCD (For Loading Data Into Memory)</a><br>
					<a href="#Command_cdpause">CDPAUSE</a><br>
					<a href="#Command_cdunpause">CDUNPAUSE</a><br>
				</tt>
				<br>
				<a name="command_cdplay"></a><i>Command_CDPLAY:</i><br>
					<i>Syntax:</i> <tt>CDPlay &lt;Track Number&gt;</tt><br>
					<i>Description:</i> Plays an audio track. The audio track is <b>not</b> played repeatedly. &lt;Track Number&gt; is the track number to play. Track number 1 is the data track that holds all the game info. Tracks above that are your audio tracks. Eg: In an emulator, if you have one of your tracks names as <tt>basic 02.mp3</tt>, to play that track, you will need to use <tt>CDPlay 2</tt>. This command can be used by both a Sega CD Master Program, and a regular Sega CD Program.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_cdplay2"></a><i>Command_CDPLAY2:</i><br>
					<i>Syntax:</i> <tt>CDPlay2 &lt;Track Number&gt;</tt><br>
					<i>Description:</i> Plays an audio track. The audio track is played <b>repeatedly</b>. &lt;Track Number&gt; is the track number to play. Track number 1 is the data track that holds all the game info. Tracks above that are your audio tracks. Eg: In an emulator, if you have one of your tracks names as <tt>basic 02.mp3</tt>, to play that track, you will need to use <tt>CDPlay 2</tt>. This command can be used by both a Sega CD Master Program, and a regular Sega CD Program.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_cdstop"></a><i>Command_CDSTOP:</i><br>
					<i>Syntax:</i> <tt>CDStop</tt><br>
					<i>Description:</i> Stops playing an audio track. This command can be used by both a Sega CD Master Program, and a regular Sega CD Program.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_addscd"></a><i>Command_ADDSCD:</i><br>
					<i>Syntax:</i> <tt>AddSCD &lt;Filename&gt;</tt><br>
					<i>Description:</i> This command adds a file to the list of programs that will be included onto the CD. This command can only be used in a Sega Boot CD Master Program (compiler output option: <i>Compile as a Sega Boot CD</i>. The file must be a pre-compiled Sega CD Program (extension .SCD). The compiler will not compile the Sega CD Program from the Master CD Program. Files are added from first to last. When it comes to loading these programs, the very first program added will have a cluster number of 2. The second file that is loaded after a previous AddSCD command will have a cluster number of 3, and if another file is added, its cluster number will be 4, etc etc. Cluster 1 is the Master Sega CD program. This is the program that is compiled as a Sega Boot CD. Cluster 0 is the CD Boot section.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_loadscd"></a><i>Command_LOADSCD: (For Loading Sega CD Programs)</i><br>
					<i>Syntax:</i> <tt>LoadSCD &lt;Cluster&gt;</tt><br>
					<i>Description:</i> This command kills execution of the current program and loads another program and runs it. When loading programs, the very first program added by AddSCD will have a cluster number of 2. The second file that is loaded by AddSCD after a previous AddSCD command will have a cluster number of 3, and if another file is added, its cluster number will be 4, etc etc. Cluster 1 is the Master Sega CD program. This is the program that is compiled as a Sega Boot CD. Cluster 0 is the CD Boot section. This command can be used by a Sega CD Master Program, and a regular Sega CD Program.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_loadscdv"></a><i>Command_LOADSCD: (For Loading VRAM Data)</i><br>
					<i>Syntax:</i> <tt>LoadSCD &lt;Cluster&gt;, &lt;VRAM&gt;, &lt;Start Position*32&gt;, &ltVRAM Destination*32&gt;, &ltNumber of tiles to copy&gt;</tt><br>
					<i>Description:</i> This command kills copies data from a cluster on a CD, and then stores it into VRAM. Mainly, this command is used to load tiles into VRAM. All parameters have to be aligned by 32 bytes (hence, a single tile is 32 bytes long). You'll have to create your own way to generate the cluster data.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_loadscda"></a><i>Command_LOADSCD: (For Loading Data Into Variables)</i><br>
					<i>Syntax:</i> <tt>LoadSCD &lt;Cluster&gt;, &lt;ARRAY&gt;, &lt;Start Position&gt;, &lt;Variable&gt;</tt><br>
					<i>Description:</i> This command loads data from a cluster on the CD, and then stores it into a variable, or an array. &lt;Start Position&gt; specifies the location within the cluster in which LOADSCD will load data into the variable. The number of bytes that are read are pre-determined by the compiler (based on the actual size of the variable or array). Putting data into the right places, and then creating an address to retrieve them is tricky. More than likely, you'll probably use a hex editor to create your data. I'll try to make a utility later that will generate clusters based on a script or something.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_loadscdp"></a><i>Command_LOADSCD: (For Loading Data Into Memory)</i><br>
					<i>Syntax:</i> <tt>LoadSCD &lt;Cluster&gt;, &lt;POINTER&gt;, &lt;Start Position&gt;, &lt;Memory Destination&gt;, &lt;Number of Bytes&gt;</tt><br>
					<i>Description:</i> This command loads data from a cluster on the Sega CD, and then stores the data into memory on the main Sega Genesis. &lt;Start Position&gt; is a LONG value that specifies which byte in the cluster the programmer wants to start copying data from. This instruction is good for loading huge chunks of data into Word RAM (where your program executes). For example, the programmer can point the Destination Address to a data statement, where the LOADSCD command can load new data into that data space.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_cdpuase"></a><i>Command_CDPAUSE:</i><br>
					<i>Syntax:</i> <tt>CDPAUSE</tt><br>
					<i>Description:</i> When a CD audio track is playing, the play can be paused by using this command.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
				<a name="command_cdunpause"></a><i>Command_CDUNPAUSE:</i><br>
					<i>Syntax:</i> <tt>CDUNPAUSE</tt><br>
					<i>Description:</i> Unpauses a paused-playing CD audio track.<br>
					<a href="#segacdcommands">Back to the Sega CD Index</a><br>
					<br>
			<a name="Functions"></a><b>Functions</b><br>
				<tt>
					<a href="#function_joypad">Joypad()</a><br>
					<a href="#function_peek">Peek()</a><br>
					<a href="#function_peek">PeekInt()</a><br>
					<a href="#function_peek">PeekLong&()</a><br>
					<a href="#function_rgb">RGB()</a><br>
					<a href="#function_addsprite">AddSprite()</a><br>
					<a href="#function_rnd">Rnd()</a><br>
					<a href="#function_spriteposx">SpritePosX()</a><br>
					<a href="#function_spriteposy">SpritePosY()</a><br>
					<a href="#function_val">Val()</a><br>
					<a href="#function_left">Left$()</a><br>
					<a href="#function_right">Right$()</a><br>
					<a href="#function_mid">Mid$()</a><br>
					<a href="#function_str">Str$()</a><br>
					<a href="#function_hex">Hex$()</a><br>
					<a href="#function_bin">Bin$()</a><br>
					<a href="#function_string">String$()</a><br>
					<a href="#function_varptr">VarPtr&()</a><br>
					<a href="#function_call">Call()</a><br>
					<a href="#function_call">Call&()</a><br>
					<a href="#function_tvscanx">TVScanX()</a><br>
					<a href="#function_tvscany">TVScanY()</a><br>
					<a href="#function_len">Len()</a><br>
					<a href="#function_dataptr">DataPtr&()</a><br>
					<a href="#function_chr">Chr$()</a><br>
					<a href="#function_chr">ChrW$()</a><br>
					<a href="#function_chr">ChrL$()</a><br>
					<a href="#function_asc">Asc()</a><br>
					<a href="#function_asc">AscW()</a><br>
					<a href="#function_asc">AscL&()</a><br>
					<a href="#function_not">Not()</a><br>
					<a href="#function_not">Not&()</a><br>
					<a href="#function_lblptr">LblPtr&()</a><br>
					<a href="#function_endcode">EndCode&()</a><br>
					<a href="#function_startcode">StartCode&()</a><br>
					<a href="#function_hfliptile">HFlipTile()</a><br>
					<a href="#function_vfliptile">VFlipTile()</a><br>
					<a href="#function_palette">Palette()</a><br>
					<a href="#function_priority">Priority()</a><br>
					<a href="#function_vdpramread">VdpRamRead()</a><br>
					<a href="#function_tvtype">TvType()</a><br>
					<a href="#function_unittype">UnitType()</a><br>
					<a href="#function_readtile">ReadTile()</a><br>
					<a href="#function_posx">PosX()</a><br>
					<a href="#function_posy">PosY()</a><br>
					<a href="#function_curink">CurInk()</a><br>
					<a href="#function_read">Read()</a><br>
					<a href="#function_readint">ReadInt()</a><br>
					<a href="#function_readlong">ReadLong&()</a><br>
					<a href="#function_readp">ReadP()</a><br>
					<a href="#function_vblankon">VBlankOn()</a><br>
					<a href="#function_hblankon">HBlankOn()</a><br>
				</tt>
			<a name="FunctionsABC"></a><b>Functions In Alphabetical Order</b><br>
				<tt>
					<a href="#function_addsprite">AddSprite()</a><br>
					<a href="#function_asc">Asc()</a><br>
					<a href="#function_asc">AscW()</a><br>
					<a href="#function_asc">AscL&()</a><br>
					<a href="#function_bin">Bin$()</a><br>
					<a href="#function_call">Call()</a><br>
					<a href="#function_call">Call&()</a><br>
					<a href="#function_chr">Chr$()</a><br>
					<a href="#function_chr">ChrW$()</a><br>
					<a href="#function_chr">ChrL$()</a><br>
					<a href="#function_curink">CurInk()</a><br>
					<a href="#function_dataptr">DataPtr&()</a><br>
					<a href="#function_endcode">EndCode&()</a><br>
					<a href="#function_hblankon">HBlankOn()</a><br>
					<a href="#function_hex">Hex$()</a><br>
					<a href="#function_hfliptile">HFlipTile()</a><br>
					<a href="#function_joypad">Joypad()</a><br>
					<a href="#function_lblptr">LblPtr&()</a><br>
					<a href="#function_left">Left$()</a><br>
					<a href="#function_len">Len()</a><br>
					<a href="#function_mid">Mid$()</a><br>
					<a href="#function_not">Not()</a><br>
					<a href="#function_not">Not&()</a><br>
					<a href="#function_palette">Palette()</a><br>
					<a href="#function_peek">Peek()</a><br>
					<a href="#function_peek">PeekInt()</a><br>
					<a href="#function_peek">PeekLong&()</a><br>
					<a href="#function_posx">PosX()</a><br>
					<a href="#function_posy">PosY()</a><br>
					<a href="#function_priority">Priority()</a><br>
					<a href="#function_read">Read()</a><br>
					<a href="#function_readint">ReadInt()</a><br>
					<a href="#function_readlong">ReadLong&()</a><br>
					<a href="#function_readp">ReadP()</a><br>
					<a href="#function_readtile">ReadTile()</a><br>
					<a href="#function_rgb">RGB()</a><br>
					<a href="#function_right">Right$()</a><br>
					<a href="#function_rnd">Rnd()</a><br>
					<a href="#function_spriteposx">SpritePosX()</a><br>
					<a href="#function_spriteposy">SpritePosY()</a><br>
					<a href="#function_startcode">StartCode&()</a><br>
					<a href="#function_str">Str$()</a><br>
					<a href="#function_string">String$()</a><br>
					<a href="#function_tvscanx">TVScanX()</a><br>
					<a href="#function_tvscany">TVScanY()</a><br>
					<a href="#function_tvtype">TvType()</a><br>
					<a href="#function_unittype">UnitType()</a><br>
					<a href="#function_val">Val()</a><br>
					<a href="#function_varptr">VarPtr&()</a><br>
					<a href="#function_vblankon">VBlankOn()</a><br>
					<a href="#function_vdpramread">VdpRamRead()</a><br>
					<a href="#function_vfliptile">VFlipTile()</a><br>
				</tt>
				<br>
				<a name="function_joypad"></a><i>Function_JOYPAD():</i><br>
					<i>Syntax: </i><tt>Integer=JOYPAD(&lt;Joypad Number&gt;)</tt><br>
					<i>Description: </i>Return the keypress state of a Joypad. Joystick 1 is specified by a &lt;Joypad Number&gt; value of 0, and joystick 2 is specified by a &lt;Joypad Number&gt; value of 1. A button pressed is indicated by a 1 in its bit.<br>
					<i>JoyPad Values</i>
						<tt><table border="0" cellpadding="0" cellspacing="0">
							<tr><td width="100"><b>Bit</b></td><td width="100"><b>Hex</b></td><td width="100"><b>Decimal</b></td><td width="100"><b>Button</b></td></tr>
							<tr><td width="100">0	</td><td width="100">&amp;h001</td><td width="100">1	</td><td width="100">Up	</td></tr>
							<tr><td width="100">1	</td><td width="100">&amp;h002</td><td width="100">2	</td><td width="100">Down</td></tr>
							<tr><td width="100">2	</td><td width="100">&amp;h004</td><td width="100">4	</td><td width="100">Left</td></tr>
							<tr><td width="100">3	</td><td width="100">&amp;h008</td><td width="100">8	</td><td width="100">Right</td></tr>
							<tr><td width="100">4	</td><td width="100">&amp;h010</td><td width="100">16	</td><td width="100">B</td></tr>
							<tr><td width="100">5	</td><td width="100">&amp;h020</td><td width="100">32	</td><td width="100">C</td></tr>
							<tr><td width="100">6	</td><td width="100">&amp;h040</td><td width="100">64	</td><td width="100">A</td></tr>
							<tr><td width="100">7	</td><td width="100">&amp;h080</td><td width="100">128	</td><td width="100">Start</td></tr>
							<tr><td width="100">8	</td><td width="100">&amp;h100</td><td width="100">256	</td><td width="100">Z (6-Button)</td></tr>
							<tr><td width="100">9	</td><td width="100">&amp;h200</td><td width="100">512	</td><td width="100">Y (6-Button)</td></tr>
							<tr><td width="100">10	</td><td width="100">&amp;h400</td><td width="100">1024	</td><td width="100">X (6-Button)</td></tr>
							<tr><td width="100">11	</td><td width="100">&amp;h800</td><td width="100">2048	</td><td width="100">Mode (6-Button)</td></tr>
						</table></tt>
					<i>3 Button and 6 Button Joystick Note</i><br>
					When using a 3-button controller, you cannot assume that the 6-button bits will be cleared. The 6-button bits are randomly (actually they're relevent to the buttons pressed but blah) set or cleared when using a 3 button joystick, so the joypad function will not always read out the exact deciaml/hex value listed above.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_peek"></a><i>Function_PEEK():</i><br><i>Function_PEEKINT():</i><br><i>Function_PEEKLONG():</i><br>
					<i>Syntax: </i><br><tt>
						Integer=PEEK(&lt;address&gt;)<br>
						Integer=PEEKINT(&lt;address&gt;)<br>
						Long=PEEKLONG&(&lt;address&gt;)</tt><br>
					<i>Description: </i>Reads a value in memory. &lt;Address&gt; is a long value that holds the address to fetch data in memory. The <tt>Peek()</tt> function reads a byte, <tt>PeekInt()</tt> reads a word, and <tt>PeekLong&()</tt> reads a long.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_rgb"></a><i>Function_RGB():</i><br>
					<i>Syntax: </i><tt>Integer=RGB(&lt;red&gt;, &lt;green&gt;, &lt;blue&gt;)</tt><br>
					<i>Description: </i>Converts red, green, and blue components into a color code for the VDP. The components range from 0 to 7, as 0 being the darkest, and 7 being the most intense. This makes a maximum of 512 colors, which is the max for Sega's VDP.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_addsprite"></a><i>Function_ADDSPRITE():</i><br>
					<i>Syntax: </i><tt>Integer=AddSprite(&lt;height&gt;, &lt;width&gt;)</tt><br>
					<i>Description: </i>Creates a new sprite to be displayed. Width and Height determine the size of the sprite, and ranges in values from 0 to 3. One unit equals one 8*8 cell (sprite sizes range from 8*8 to 32*32). Sprite sizes cannot be changed once the sprite is created. Returns the sprite number handle that is used for other sprite routines.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_rnd"></a><i>Function_RND():</i><br>
					<i>Syntax: </i><tt>Integer=RND(&lt;random range&gt;)</tt><br>
					<i>Description: </i>Returns a random number. &lt;random range&gt; specifies the maximum value to return, and starts from 1 to 65535. Use the <tt>Randomize</tt> command to make sure a unique value is returned from <tt>RND</tt>.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_spriteposx"></a><i>Function_SPRITEPOSX():</i><br>
					<i>Syntax: </i><tt>Integer=SpritePosX(&lt;sprite number&gt;)</tt><br>
					<i>Description: </i>Returns the verticle position of a sprite. &lt;sprite number&gt; is the handle of the sprite.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_spriteposy"></a><i>Function_SPRITEPOSY():</i><br>
					<i>Syntax: </i><tt>Integer=SpritePosY(&lt;sprite number&gt;)</tt><br>
					<i>Description: </i>Returns the horizontal position of a sprite. &lt;sprite number&gt; is the handle of the sprite.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_val"></a><i>Function_VAL():</i><br>
					<i>Syntax: </i><tt>Integer or Long=Val(&lt;string expression&gt;)</tt><br>
					<i>Description: </i>Converts a string number into an integer or long number.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_left"></a><i>Function_LEFT():</i><br>
					<i>Syntax: </i><tt>String=Left$(&lt;string expression&gt;, &lt;length&gt;)</tt><br>
					<i>Description: </i>Returns a string that comprises the left-most characters of a string. &lt;string expression&gt; is the string to be extracted from. &lt;length&gt; is the number of characters to extract.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_right"></a><i>Function_RIGHT():</i><br>
					<i>Syntax: </i><tt>String=Right$(&lt;string expression&gt;, &lt;length&gt;)</tt><br>
					<i>Description: </i>Returns a string that comprises the right-most characters of a string. &lt;string expression&gt; is the string to be extracted from. &lt;length&gt; is the number of characters to extract.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_mid"></a><i>Function_MID():</i><br>
					<i>Syntax: </i><tt>String=Mid$(&lt;string expression&gt;, &lt;start&gt;, [length])</tt><br>
					<i>Description: </i>Returns a string within another string. &lt;string expression&gt; is the source string to get the characters from. &lt;start&gt; is the start position of the source string to start copying from. &lt;start&gt; begins at 0 for the 1st character. [length] is the length of the string that will be returned. If [length] is ommited, then the maximum number of characters will be returned.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_str"></a><i>Function_STR():</i><br>
					<i>Syntax: </i><tt>String=Str$(&lt;non-string expression&gt;)</tt><br>
					<i>Description: </i>Converts a non-string number into a string.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_hex"></a><i>Function_HEX():</i><br>
					<i>Syntax: </i><tt>String=Hex$(&lt;number&gt;)</tt><br>
					<i>Description: </i>Converts a long number into a string, formatted in hex. The length of the string is 8 characters, for a 32-bit number. Use string parsing functions to concave down.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_bin"></a><i>Function_BIN():</i><br>
					<i>Syntax: </i><tt>String=Bin$(&lt;number&gt;)</tt><br>
					<i>Description: </i>Converts a long number into a string, formatted in binary. The length of the string is 32 characters, for a 32-bit number. Use string parsing functions to concave down.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_string"></a><i>Function_STRING():</i><br>
					<i>Syntax: </i><tt>String=String$(&lt;character&gt;, &lt;length&gt;)</tt><br>
					<i>Description: </i>Returns a string whose characters all have the same specified character. &lt;character&gt; is a string were the first character is the character to use for filling the destination string. &lt;length&gt; is the length of the string to create.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_varptr"></a><i>Function_VARPTR():</i><br>
					<i>Syntax: </i><tt>Long=VarPtr&(&lt;variable&gt;)</tt><br>
					<i>Description: </i>Gets the memory address of the variable.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_call"></a><i>Function_CALL():</i><br>
					<i>Syntax: </i><br>
						<tt>Integer=Call(&lt;asm routine name&gt;, [argument 1], [argument 2],...., [argument n])</tt><br>
						<tt>Long=Call&(&lt;asm routine name&gt;, [argument 1], [argument 2],...., [argument n])</tt><br>
					<i>Description: </i>Calls the assembly routine and returns its return value. &lt;asm routine name&gt; is the routine's label to call. The arguments are passed to the routine with the heap. The routine must store its return value in D0. See the <a href="#command_call"><tt>Call</tt></a> command for more details.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_tvscanx"></a><i>Function_TVSCANX():</i><br>
					<i>Syntax: </i><tt>Integer=TVScanX()</tt><br>
					<i>Description: </i>Returns the verticle position of the TV beam. This value is not valid during verticle blank. This value is copied directly from the VDP's HV counter.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_tvscany"></a><i>Function_TVSCANY():</i><br>
					<i>Syntax: </i><tt>Integer=TVScanY()</tt><br>
					<i>Description: </i>Returns the horizontal position of the TV beam. This value is not valid during verticle blank. This value is copied directly from the VDP's HV counter.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_len"></a><i>Function_LEN():</i><br>
					<i>Syntax: </i><tt>Integer=Len(&lt;string expression&gt;)</tt><br>
					<i>Description: </i>Gets the length of a string. &lt;string expression&gt; is the string.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_dataptr"></a><i>Function_DataPtr&():</i><br>
					<i>Syntax: </i><tt>Long=DataPtr&()</tt><br>
					<tt>DataPtr&()=Long</tt><br>
					<i>Description: </i>Reads the current value of the data pointer. One unit of DataPtr&() is one byte. Use <tt>DataPtr&=<i>Expression</i></tt> to relocate the data pointer. For example, <tt>DataPtr&=DataPtr&()+1</tt> will increase the data pointer by one byte. The previous line of code can actually be written as <tt>dataptr&++</tt> also - immediate operators also work for setting the data pointer, eg: <tt>DataPtr&--</tt>.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_chr"></a><i>Function_Chr$():<br>Function_ChrW$():<br>Function_ChrL$():</i><br>
					<i>Syntax: </i><br>
					<tt>String$=Chr$(&lt;integer/long expression&gt;)</tt><br>
					<tt>String$=ChrW$(&lt;integer/long expression&gt;)</tt><br>
					<tt>String$=ChrL$(&lt;integer/long expression&gt;)</tt><br>
					<i>Description: </i>Converts the number expression into a string. For example, if the expression were to be &h61, then it would convert into the ASCII character A using chr$(). Word and long sized values can be created also. Note: when using ChrW$() or ChrL$(), if the place that the function is being placed is on an odd (2nd character, 4th character, etc) position in the string, a space will be inserted. This is due to the 68k's architecture.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_asc"></a><i>Function_Asc():<br>Function_AscW():<br>Function_AscL&():</i><br>
					<i>Syntax: </i><br>
					<tt>Something=Asc(&lt;string expression&gt;)</tt><br>
					<tt>Something=AscW(&lt;string expression&gt;)</tt><br>
					<tt>Something&=AscL&(&lt;string expression&gt;)</tt><br>
					<i>Description: </i>Converts a string into its real number. For example, to get the ASCII code for character A, you could use <tt>Print Asc("A")</tt>. This value can then be sent back to a function like Chr$() to convert the character A back.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_not"></a><i>Function_Not():<br>Function_Not&():</i><br>
					<i>Syntax: </i><br>
					<tt>Something=Not(&lt;expression&gt;)</tt><br>
					<tt>Something&=Not&(&lt;expression&gt;)</tt><br>
					<i>Description: </i>Returns the bit-wise inverse of the expression.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_lblptr"></a><i>Function_LblPtr&():</i><br>
					<i>Syntax: </i> <tt>Long=LblPtr&(&lt;Data Label&gt;)</tt><br>
					<i>Description: </i>Returns the absolute address of the data label. This can be used when you want to know the address of some data label for assembly commands.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_endcode"></a><i>Function_EndCode&():</i><br>
					<i>Syntax: </i> <tt>Long=EndCode&()</tt><br>
					<i>Description: </i>Returns the absolute address of the end of code in the compiled basic program.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_startcode"></a><i>Function_StartCode&():</i><br>
					<i>Syntax: </i> <tt>Long=StartCode&()</tt><br>
					<i>Description: </i>Returns the absolute address of the start of code in the compiled basic program.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_hfliptile"></a><i>Function_HFlipTile():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=HFlipTile(&lt;Flip Condition&gt;)</tt><br>
					<i>Description: </i>Flips a tile horizontally. This function is used by adding the value of this function to the tile number. If &lt;Flip Condition&gt; then the tile is not flipped. If it is 1 then it is flipped.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_vfliptile"></a><i>Function_VFlipTile():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=VFlipTile(&lt;Flip Condition&gt;)</tt><br>
					<i>Description: </i>Flips a tile verticle. This function is used by adding the value of this function to the tile number. If &lt;Flip Condition&gt; then the tile is not flipped. If it is 1 then it is flipped.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_palette"></a><i>Function_Palette():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=Palette(&lt;Palette Number&gt;)</tt><br>
					<i>Description: </i>Changes the palette number of the tile being drawn. This function is used by adding the value of this function to the tile number. &lt;Palette Number&gt; is the palette number, eg 0,1,2, and 3.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_priority"></a><i>Function_Priority():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=Priority(&lt;Priority Condition&gt;)</tt><br>
					<i>Description: </i>Changes the condition of the prioirty of a drawn tile. This function is used by adding the value of this function to the tile number. If &lt;Flip Condition&gt; then the tile is drawn at lower priority. If it is 1 then the tile is drawn at higher priority.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_vdpramread"></a><i>Function_VdpRamRead():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=Priority(&lt;Address&gt;)</tt><br>
					<i>Description: </i>Reads a word in VRAM. &lt;Address&gt; is an even address to read. VRAM is 64 kilobytes long. Returns a 16-bit, 2 byte value.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_tvtype"></a><i>Function_TvType():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=TvType()</tt><br>
					<i>Description: </i>Returns 0 if the designated system is an NTSC machine. Returns 1 if the designated system is a PAL machine.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_unittype"></a><i>Function_UnitType():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=UnitType()</tt><br>
					<i>Description: </i>Returns 0 if the machine was released domestic. Returns 1 if the machine was released overseas. Domestic means Japan, and anywhere else would be overseas.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_readtile"></a><i>Function_ReadTile():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=ReadTile(&lt;X&gt;,&lt;Y&gt;)</tt><br>
					<i>Description: </i>Reads the tile value in VRAM and returns it in 2-bytes (16 bit). X and Y are the coordinates, where one unit is equal to 8 pixels, or one tile.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_posx"></a><i>Function_PosX():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=PosX()</tt><br>
					<i>Description: </i>Reads the X value of the text cursor.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_posy"></a><i>Function_PosY():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=PosY()</tt><br>
					<i>Description: </i>Reads the Y value of the text cursor.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_curink"></a><i>Function_CurInk():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=CurInk()</tt><br>
					<i>Description: </i>Reads the drawing color palette value for text and graphics.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_read"></a><i>Function_Read():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=Read()</tt><br>
					<i>Description: </i>Just like the <a href="#command_read"><tt>Read</tt></a> command, but doesn't use any variables.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_readint"></a><i>Function_ReadInt():</i><br>
					<i>Syntax: </i> <tt>Integer or Long=ReadInt()</tt><br>
					<i>Description: </i>Just like the <a href="#command_read"><tt>ReadInt</tt></a> command, but doesn't use any variables.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_readlong"></a><i>Function_ReadLong():</i><br>
					<i>Syntax: </i> <tt>Long=Readlong&()</tt><br>
					<i>Description: </i>Just like the <a href="#command_read"><tt>Readlong</tt></a> command, but doesn't use any variables.<br>
					<a href="#FunctionsABC">Back to the ABC Functions Index</a><br>
					<br>
				<a name="function_readp"></a><i>Function_ReadP():</i><br>
					<i>Syntax:</i> <tt>Integer or Long = ReadP(&lt;Variable Name&gt;)</tt><br>
					<i>Syntax:</i> <tt>Long = ReadP&(&lt;Variable Name&gt;)</tt><br>
					<i>Syntax:</i> <tt>String = ReadP$(&lt;Variable Name&gt;)</tt><br>
					<i>Description:</i> Reads data from an 8-bit ram into a variable. ReadP (stands for Read-Peripheral) is mostly used to external battery bakup ram that is provided on the game cartridge. ReadP handles data differently compared to normal storage operations (eg: <tt>myvar = ext_a ' Won't work in external ram unless the ram is 16-bits</tt>). The first argument specifies the external ram variable to access data. When executed, the function will return the normalized value from the external ram variable.<br>
					<a href="#FunctionsABC">Back to the ABC Command Index</a><br>
					<br>
				<a name="function_readscroll"></a><i>Function_ReadScroll():</i><br>
					<i>Syntax:</i> <tt>Integer or Long = ReadScroll(&lt;LEFT/RIGHT/UP/DOWN&gt;, [Entry Number])</tt><br>
					<i>Description:</i> Reads data from the video scrolling memory. This function can read both LEFT and RIGHT scrolling data, or UP and DOWN scrolling data, specified in the first argument. Depending on the scrolling mode that you are using, you will get different numbers returned (eg: 2 cell verticle scroll mode vs. scrolling the entire screen horizontally). You can specify the scrolling entry number in [Entry Number]. If the entry number is ommitted, then the first entry (entry number 0) will be returned.<br>
					<br>
				<a name="function_vblankon"></a><i>Function_VBlankOn():</i><br>
					<i>Syntax:</i> <tt>Integer or Long = VBlankOn()</tt><br>
					<i>Description:</i> Returns true when the program is in the verticle blanking portion of the video display. Good for when detecting if your code is in verticle blank or not.<br>
					<br>
				<a name="function_hblankon"></a><i>Function_HBlankOn():</i><br>
					<i>Syntax:</i> <tt>Integer or Long = HBlankOn()</tt><br>
					<i>Description:</i> Returns true when the program is in the horizontal blanking portion of the video display. Good for when detecting if your code is in horizontal blank or not. It's very likely that this function is useless in BasiEgaXorz because the program stays in horizontal blanking for a very short period (~16uS), making it hard for your program to detect when in horizontal blanking.<br>
					<br>
			<a name="Operators"></a><b>Operators</b><br>
				Operations are executed in the order from the level list (starting from level 1) below, and then are executed from left to right.<br>
				<i>Order of Operations:</i><br>
				<ul>
					<li>Level 1: Immediate
					<ul><tt>
						<li><a href="#Functions">Functions</a>
						<li>() Paranthesis
					</tt></ul>
					<li>Level 2: Normal Arithmatic
					<ul><tt>
						<li>+ (Addition)
						<li>- (Subtraction)
						<li>* (Multiply)
						<li>/ (Divide)
						<li>% (Modulo)
						<li><< (Shift Left)
						<li>>> (Shift Right)
					</tt></ul>
					<li>Level 3: Comparator Operators
					<ul><tt>
						<li>= (Equals)
						<li>&lt; (Less Than)
						<li>&gt; (Greater Than)
						<li>&gt;= (Greater Than or Equal To)
						<li>&lt;= (Less Than or Equal To)
						<li>!= (Not Equal To)
					</tt></ul>
					<li>Level 4: Logical Operators
					<ul><tt>
						<li>[AND]: Logical AND
						<li>[OR]: Logical OR
						<li>[XOR]: Logical XOR
					</tt></ul>
				</ul>
			<a name="DataTypes"></a><b>Data Types</b><br>
				<i>Integer:</i> Values: -32,768 to 65,535 (2 bytes long)<br>
				<i>Long: </i>Values: -2,147,483,648 to 2,147,483,647 (4 bytes long)<br>
				<i>String:</i> If not dimensioned, then the default fixed size for a string is 128 bytes (127 characters + Null). The default value of 128 can be changed with the command <tt>Option STRING_SIZE</tt>. I will not add in support for dynamic strings because they take too much execution time to use x.x. This version of BASIC is aimed for speed. If the string is dimensioned, then the number of characters it can hold is declared by you.<br>
				<br>
			<a name="arrays"></a><b>Arrays and Multi-Dimensional Arrays</b><br>
				Starting with version 0.40 of BasiEgaXorz, the compiler can now handle multi-dimensional arrays. Previous versions could only use arrays that were singal dimension, and there was very limited support for string arrays. An important note to make is that arrays have to be predimensioned prior to using them. The compiler won't dimension an array for you if you don't use the <tt>DIM</tt> statement. When dimensioning an array, be sure to keep in mind that the Sega Genesis has only 64KBytes of RAM memory to work with. BasiEgaXorz will use somewhere around 40-60 bytes to hold hardware registers, mode settings, and system settings. The Heap and Stack will also use some memory also for holding temporary values. An array can be simply dimensioned for integer, or long, or string data types using this syntax:<br>
				<br>
				<ul>
					<li><tt>DIM MyArray(10,10,10) as Long</tt><br>
					<li><tt>DIM MyArray2(100) as Integer</tt><br>
					<li><tt>DIM MyArray3(41) as String*2</tt><br>
					<li><tt>DIM MyArray4(12,12) as String*8</tt><br>
					<li><tt>DIM MyArray4(1,2,3,4) as String ; Note that this command will allocate an array that is 15,360 Bytes in size!</tt><br>
				</ul>
				These arrays can be accessed like so:<br>
				<pre>
		MyArray&(1,2,3) = 123456789
		Print MyArray&(1,2,3)
				</pre>
				The compiler adds one more entry to the dimension of the array. For example, if you declared an array using <tt>DIM MyArray(10) as Long</tt>, then the compiler will actually create an array with 11 array entries instead of 10. The programmer can then access the array using all 11 entries, like using <tt>MyArray&(0) = 1234</tt> or <tt>MyArray&(10) = 5678</tt> without overwriting another variable's data space. When accessing arrays, array dimensions are not bounded, so if the programmer goes over the array's limit, like <tt>MyArray&(11) = 666</tt>; when the code executes, the next variable declared will be corrupted.<br>
				<br>
				String arrays can be accessed in two ways. The first way is to make the compiler access them by treating the array as an actual string (eg: A string of characters). The second way (and the traditional BasiEgaXorz way) is to access strings like byte data (eg: on character at a time). The first method of accessing strings in BasiEgaXorz is almost like accessing normal strings in QBasic. For example:<br>
				<br>
				<pre>
		DIM Names(4,1) as String<br>
		Names$(0,0) = "Bob"
		Names$(1,0) = "Bill"
		Names$(2,0) = "Jane"
		Names$(3,0) = "Harry"
		FOR A = 0 to 3
			PRINT Names$(A,0),
		NEXT
				</pre>
				<br>
				Strings can be accessed using the second method by including an extra dimension to the array. The extra dimension specifies which character, or byte you want to access. If the programmer accesses a string array using this method, then the data type is handled like an integer, or a long data type. For example:<br>
				<pre>
		FOR A=0 to 3
			FOR Char = 0 to 8
				PRINT CHR$(Names$(A,0,Char));
				' Note the CHR$() in this line -> The character is
				' actually handled like an integer or long data type
			NEXT
		NEXT
				</pre>
				Accessing strings by characters can be good for making levels, or when the programmer wants more speed than the MID$() instruction. When using * to set the size of the string, the compiler will ALWAYS add one more byte to the number to compensate for the null character, and will then make sure that the resulting size is always even (since we're using a 16-bit processor).<br>
				<br>
			<a name="Argunerics"></a><b>Argunerics</b><br>
				Arguneric is a word that I made up, and its one thing that google can't find =).<br>
				Argunerics are extensions to variable and functions. They extract individual bits out of them. The arguneric is placed right after the variable or function, seperated by a period.<br>
				<i>For example</i>, to extract bit 6 out of a variable, do the following:<br>
				<tt>MyVar=Whatever.6 ' Whatever is the variable name, and 6 is the bit number</tt>
				Also, you can specify what bit you want in another variable.<br>
				<tt>MyBit=6 ' Store the bit number in a variable</tt><br>
				<tt>MyVar=Hello.MyBit ' Extract bit MyBit of Hello into MyVar</tt><br>
				An expression is said to be <tt>TRUE</tt> when it contains any value other than 0. An expression is said to be <tt>FALSE</tt> when it contains the value of 0<br>
				Knowing this, argunerics can be used sequentially with the <tt>If</tt> command. For example, to detect for the START button:<br>
				<tt>If Joypad().7 Then Print &quot;START IS PRESSED&quot;</tt>
				Later on, argunerics will be expanded to other things other than bit numbers.<br>
				<br>
			<a name="Immediate"></a><b>Immediate Operators</b><br>
				<i>Increment Integer/Long</i><br>
				<i>Description+Usage: </i>Increases an integer/long number variable by 1. To use, just insert the variable name on the first line, and end it with a ++, like in C<br>
				<i>Examples: </i><br>
				<tt>Foo++</tt><br>
				<tt>Ogla[a+3]++</tt><br>
				<tt>Frag&++</tt><br>
				<br>
				<i>Decrement Integer/Long</i><br>
				<i>Description+Usage: </i>Decreases an integer/long number variable by 1. To use, just insert the variable name on the first line, and end it with a --, line in C<br>
				<i>Examples: </i><br>
				<tt>Foo--</tt><br>
				<tt>Ogla[a+3]--</tt><br>
				<tt>Frag&--</tt><br>
				<br>
			<a name="userfuncs"></a><b>User-Defined Functions and Subroutines</b><br>
				First, before going over functions and subroutines in BasiEgaXorz, we'll need to define some terminology. The purpose of functions and subroutines are to organize code easier, and to seperate the main variables from the local ones inside a specific region. Any region oustide functions and subroutines is called the main loop. The main loop is the starting point in your program, and can contain variables both local and global to functions and subroutines. Functions and subroutines are totally seperated from the main loop, which is why functions and subroutines give your program much more flexibility, and can keep your code better organized.<br>
				<br>
				Variables are defined as global by using the <tt>GLOBAL</tt> command to declare a variable (and then use the same syntax as the <tt>DIM</tt> command). The concept of global and local variables is important because it will define which variables will be seperated from the main loop, and then other functions. Usually, very important variables are defined as global, as in you want other functions to access the same variable. There really is no way to say that having too many globabl variables is bad for your program. First, in BasiEgaXorz, the advantages of using global variables is that not that many parameters will need to be pushed onto the stack (making function calling very fast), the compiler won't need to declare more new local variables, and using globabl variables will consume less heap space compared to pushing new variables onto the heap. The disadvantages of using global variables is that your program will basically lack flexibility. Keep in mind that the Sega Genesis is an 8MHz processor with only 64kbytes of memory, so it's your call. Programs will suffer in performance if your program makes too many calls to functions. The compiler can also declare global variables automatically through compiler options. Local variables will then have to be defined by using the <tt>LOCAL</tt> statement. If automatic global variables are turned off, then any variables declared using <tt>DIM</tt> are automaticaly made local. The only variables that cannot be defined in the parameters list are arrays. Functions cannot return array values either.<br>
				<br>
				Functions are declared using: <tt>Declare Function FunctionName(Parameter1 as Data Type, Parameter2 as Data Type, ...) as Data Type</tt>. The data type for parameters, and the returning value can either be Integer, or Long, or String. Parameter1 and Parameter2 can be any variable name the programmer wishes to store parameters, and then retrieve the values when the function is called. Functions and subroutines must be visible during Pass 1 of compilation. In order to be visible, there must be absolutely no space at the begining of <tt>Declare</tt>, or else the compiler is going to give you many errors! Use <tt>End Function</tt> to go back to coding in the main loop.<br>
				<br>
				Functions are exitted by using the <tt>RETURN</tt> or <tt>EXIT FUNCTION</tt> commands. The returned value is also sent through the <tt>RETURN</tt>, or through <tt>EXIT FUNCTION</tt>, where the value to return is included in the last parameter of these commands. Finally, here is a small example of a function:<br>
				<pre>
	num1& = 1234: num2& = 5678
	print "Original Values: ", num1&, num2&
	print "43656 + 657769 = "; Add&(43656, 657769)
	print "Anything Changed? ", num1&, num2&

Declare Function Add(num1 as Long, num2 as Long) as Long
	Return num1&+num2&
End Function
				</pre>
				Subroutines are almost exactly the same as functions, but instead, cannot return values. Subroutines are declared using <tt>Decalre Sub SubName(Parameter1 as Data Type, Parameter2 as Data Type, ...)</tt>. You can exit out of subroutines using <tt>Return</tt> or <tt>Exit Sub</tt>. Calling subroutines is easy, for example:<br>
				<pre>
	Global time as Long
	time& = 1000
	AddTime 60
	Print time

Declare Sub AddTime(numtoadd as Long)
	time& = time& + numtoadd&
	Exit Sub
End Sub
				</pre>
				Functions and subroutines can be recursized in BasiEgaXorz. The compiler will pre-record all the variables that are included in a subroutine, and then compare it with the variables outside the subroutine. Any variables in the main loop will be pushed onto the heap, so that your function can then use the variable space. When the functions exits, the original values from the variables in the main loop will be put back. This goes for the same in recursizing functions, when a function executes, old values from variables will be pushed onto the heap, and then will be popped back when it leaves. Be sure to not recursize too many functions, or allocate too many variables in the main loop, so that there's very little space for the heap and stack to work with. The more variables you use inside your functions, the more heap space you will need.<br>
				<br>
			<a name="advanced"></a>
			<a name="sinescosines"></a><b>Sines/Cosines</b><br>
				Sine and cosine values are not generated during run-time, and they will never be. I know that this isn't 'Modern Day BASIC Protocol', and sines/cosines are essential to games now these days (circles, bouncy text, objects on a line, projectiles, whatever). But these is another method to generate sines and cosines. Go to <a href="http://www.anthrox.com/soft/indexsoft.html">-Pan- of Anthrox's-</a> site and download Roller Coaster. It will generate the sine and cosine values for whatever waves you need, so you can just plug the values into your program with a Data statement and such. Doing this is a whole lot faster, and saves lots of memory compared to generating sines and cosines during run-time =).<br>
				<br>
			<a name="interrupts"></a><b>Interrupters</b><br>
				Two interrupters are currently supported. There is the <a href="#horizontal_interrupt">horizontal</a> interrupt, and <a href="#verticle_interrupt">verticle</a> interrupt.<br>
				<br>
				<a name="verticle_interrupt"></a><i>Verticle Interrupter</i><br>
				The verticle blank stays active for 20 scan lines, which is about 1.27 ms. If you want your interrupt to finish before the screen starts to be redrawn, you gotta make your interrupt code small. Warning, when updating the screen inside the verticle interrupt, some commands might mess up the screen. For example, if the main execution loop is displaying a string, and then a verticle interrupt occurs and starts drawing another string, the string that is drawn during the verticle interrupt might insert its characters in before the command in the main loop finishes its drawing. The case is rare, the timings have to be just right. For some commands, all interrupts are disabled, and are re-enabled when they are done finishing execution. Most of these commands are display routines.<br>
				<br>
				<a name="horizontal_interrupt"></a><i>Horizontal Interrupter</i><br>
				The verticle blank stays active less than about 12 us (micro-seconds). No more than 12 assembly commands can be executed during this period (assuming each instruction is 1 us, which is the 'best case' execution time). There is a counter that counts down each time a horizontal blank occurs. When this counter drops to 0, a horizontal interrupt occurs. This counter can be pre-set using the <tt>HBALNK</tt> command.<br>
				<br>
			<a name="asm"></a><b>Machine Code Language</b><br>
				There are so many low level things in the Sega that i can't simply catagorize under this BASIC document, including the stuff for BasiEgaXorz's low level routines itself. Any assembly language questions should be asked on the forums. Look down at contacts at the very end on the document. Also look at the <tt>Call</tt> command for simple stuff.<br>
				<br>
			<a name="userasmfuncs"></a><b>User Defined Assembly Language Subroutines and Functions</b><br>
				Assembly language subroutines and functions have the same format as regular user defined functions and subroutines that was introduced in v1.00 of the compiler. The only difference in assembly language functions, or subroutines is that the actual routine code is coded in assembly language, which is much faster than compiled basic code. With assembly language functions and subroutines, the programmer is able to define a function, or subroutine with a list of parameters, which will actually be the CPU registers (d0-d7 for data, or a0-a7 for a pointer). To get started, an assembly language function or subroutine can be defined as follows:<br>
				<br>
				<pre>
' For a subroutine
Declare Asm Sub SubroutineName(Parameter List)
End Sub

' For a function that has a return value
Declare Asm Function FunctionName(Parameter List)
	' Return the value of 123
	move.l	#123,d0
End Function
				</pre>
				The paramter list specifies which values from the called function go into the CPU registers. The parameter list can accept the data registers, d0-d7, which will return the actual values of what the programmer passes to the sub or function. When specifying a data register, the size of the data register (byte, word, or long) has to be specified somewhere in the parameter list, along with the actual data register. For instance, to put a byte value into d0, you could use either the <tt>d0.b</tt> or <tt>d0 as byte</tt> (both will do the same thing). The same goes for word, and long data types. If an address register, a0-a7, is specified, the pointer that holds the value that is passed to the sub or function will be returned. The pointer will only return the value in the heap. It will not return the actual location of a variable. A size doesn't have to be specified for address registers, since a long, or 32-bit magnitude is always assumed. However, a data type has to be specified for an address register, so that the compiler will be able to distinguish whether it should return a pointer for an integer value, or a long value, or a string (all which have different offsets in the heap).<br>
				<br>
				Acceptable parameters:
				<pre>
d0.l
d0 as long
d2.b
d3 as byte
d0.w
d5.w
d6 as word
a0 as integer
a1 as long
a2 as string
				</pre>
				An example of a user-defined assembly function:<br>
				<pre>
Declare Asm Function FunctionName(d0.b, d1.l, a0 as string, a1 as integer, a2 as long)
	add.b	#1,d0			; add 1 to the first parameter (byte)
	lsr.l	#4,d1			; Shift the second parameter right by 4 times (long)
	movem.l	d0/d1/a1/a2,-(a7)	; print_c might trash our values
	move.b	(a0)+,d0		; Print the first two characters in the third parameter (string)
	jsr	print_c
	move.b	(a0)+,d0
	jsr	print_c
	movem.l	(a7)+,d0/d1/a1/a2	; Restore the value of d0,d1,a1, and a2
	move.l	(a2),d3			; Retrieve the value of the fourth parameter and store it in d3 (long)
	ext.w	d0
	ext.l	d0
	add.l	d3,d0
	add.l	d1,d0			; Return d0+d1+d3
End Function
				</pre>
				To call the above example in a program, a programmer might use something like this:<br>
				<pre>
	MyVar& = FunctionName(123, 65536*65536-1, "Hello!", 45, &h12345678)
				</pre>
				Tips: Remember, BasiEgaXorz uses the heap to pass values between calling the function, and executing the actual function. Therefore, when updating values that are pointed by address registers, the value only gets updated in the heap, which will be garbage collected after the function is finished being executed. To insert labels into your function, you need to use local labels. In SNASM assembler, you use local labels by tacking on a &#64; to the front of your label, eg: <tt>&#64;MyLabel: bra.s &#64;MyLabel</tt>.<br>
				<br>
				Feel free to use address registers a0-a2 in your assembly language subroutine. Address registers a3-a7 are special registers that basic will use, which must not be modified by the function. A3 holds the address of the start of the stack. Modifying A3 won't mess up your program, but you will lose track of where the heap starts for your function. A4 holds the video port address for fast access. A5 holds the current position of the heap. Your function can use the heap as much as it wants, to hold values, or whatever. For example, you can use it like <tt>move.l #123,4(a5)</tt> or whatever. A6 holds the current position of the data pointer. A7 holds the stack position. Modifying A3 and A5 won't do any harm to your BASIC program.<br>
				<br>
			<a name="lowvideo"></a><b>Low-Level Video Setup</b><br>
					<i>Default VRAM Map</i>
					<pre>
<b>Scroll B</b>                   = $E000 - $FFFF [8192 Bytes]
<b>Scroll A</b>                   = $C000 - $DFFF [8192 Bytes]
<b>Patterns</b> (Tiles 1520-1535) = $BE00 - $BFFF [1856 Bytes]
<b>Window</b>                     = $B000 - $BDFF [2240 Bytes]
<b>Patterns</b> (Tiles 1396-1407) = $AE80 - $AFFF [384 Bytes]
<b>Sprites</b>                    = $AC00 - $AE7F [640 Bytes]
<b>H Scroll</b>                   = $A800 - $ABFF [1024 Bytes]
<b>Patterns</b> (Tiles 0-1343)    = $0000 - $A7FF [43008 Bytes]
					</pre>
				<i>Default VDP Register Setup are as follows:</i><br>
				<tt>
					move.w #$8006,($C00004) ; Mode #1<br>
					move.w #$8154,($C00004) ; Mode #2<br>
					move.w #$8B00,($C00004) ; Mode #3<br>
					move.w #$8C81,($C00004) ; Mode #4<br>
					move.w #$8700,($C00004) ; Background<br>
					move.w #$8800,($C00004) ; Low<br>
					move.w #$8900,($C00004) ; Low<br>
					move.w #$8230,($C00004) ; Scroll A Name Table<br>
					move.w #$832C,($C00004) ; Window<br>
					move.w #$8407,($C00004) ; Scroll B Name Table<br>
					move.w #$9011,($C00004) ; 64*64<br>
					move.w #$9100,($C00004) ; Window X<br>
					move.w #$9200,($C00004) ; Window Y<br>
					move.w #$8556,($C00004) ; Sprites Name Table<br>
					move.w #$8600,($C00004) ; Low<br>
					move.w #$8D2A,($C00004) ; H Scroll<br>
					move.w #$8E00,($C00004) ; Low<br>
				</tt>
				<br>
			<a name="sega32xcommands"></a><b>Programming for the 32X Extension</b><br>
				Note: <b>All commands have to have a space/tab in front.</b> Sega 32X specific commands can only be used on projects that are compiled as a 32X Rom. Only this can be enabled through the options dialog. There is no <tt>OPTION</tt> command inside BASIC to make the compiler compile for 32X.<br>
				<br>
				This section describes the commands and methods that BasiEgaXorz uses to communicate with the 32X peripheral. This section does not give a very friendly overview on how the 32X extension actually works, or how the different video modes work. Places to read up more on the 32X are located at <a href="http://devster.monkeeh.com/sega/32xguide1.txt">http://devster.monkeeh.com/sega/32xguide1.txt</a>, which is my 32x guide. Another useful place for 32X documents is fonzie's website, which is located at <a href="http://www.genny4ever.net/index.php?page=docs">Fonzie's Document Site</a>. You will need to understand how the 32X video controller works, before you can actually use it in BasiEgaXorz using the frame buffer arrays.<br>
				<ul>
					<li><b>32X Commands</b>
						<ul>
							<li><tt><a href="#command_marsswapbuffer">MARSSWAPBUFFER</a></tt>
							<li><tt><a href="#command_marsvidmode">MARSVIDMODE</a></tt>
							<li><tt><a href="#command_marsvidrequest">MARSVIDREQUEST</a></tt>
						</ul>
					<li><b>32X Functions</b>
						<ul>
							<li><tt>None exist at the moment</tt>
						</ul>
					<li><b>32X Variables</b>
						<ul>
							<li><tt><a href="#var_marsvram">MARSVRAM</a></tt>
							<li><tt><a href="#var_marsvramow">MARSVRAMOW</a></tt>
							<li><tt><a href="#var_marscram">MARSCRAM</a></tt>
						</ul>
				</ul>
				<br>
				<a name="command_marsswapbuffer"></a><i>Command_MARSSWAPBUFFER:</i><br>
					<i>Syntax:</i> <tt>MarsSwapBuffer</tt><br>
					<i>Description:</i> Swaps the dual video buffers for the 32X display. The 32X extension utilizes a dual frame buffer type of controller for the display. One of the buffers will be dedicated to the display, and another buffer will be dedicated to drawing. The CPU has unlimited access to the buffer that is used for drawing, as in the CPU does not have to wait for the video controller to finish displaying, before the CPU can access the drawing buffer. Instead, the video controller will display the contents of the frame buffer that is being used as the display buffer. While the CPU is drawing to the drawing buffer, the user will not be able to see the changes made to the drawing buffer, until the frame buffers are swapped. When the buffers are swapped, the display buffer now becomes the drawing buffer, and the drawing buffer is now able to be seen on the TV. The command used to swap the frame buffers in BasiEgaXorz is <tt>MARSSWAPBUFFER</tt>.<br>
					<br>
					The whole point of having dual frame buffers is to speed up access between the CPU and video memory, and to prevent drawing changes from being shown on the screen while the display is being displayed. The buffers need to be swapped when the programmer has finished updating the current gaming screen. This command also waits for VBLANK before swapping the buffers.<br>
					<a href="#sega32xcommands">Back to the 32X Section</a><br>
					<br>
				<a name="command_marsvidmode"></a><i>Command_MARSVIDMODE:</i><br>
					<i>Syntax:</i> <tt>MarsVidMode &lt;Drawing Mode&gt;, &lt;TV Format&gt;, &lt;Priority Control&gt;</tt><br>
					<i>Description:</i> This command sets the different video modes of the display controller. The 32X has three different display modes: Packed Pixel Mode, Direct Pixel Mode, and RLE Mode. The first argument in this command specifies the mode: <tt>DM_BLANK</tt> (Display off), <tt>DM_PACKED</tt> (Packed Pixel Mode, or 8 bits-per-pixel <tt>DM_8BPP</tt>), <tt>DM_DIRECT</tt> (Direct Pixel Mode, or 15 bits-per-pixel <tt>DM_15BPP</tt>), and <tt>DM_RLE</tt> (RLE Mode).<br>
					<br>
					The second argument specifies what type of TV will be hooked up to the 32X. This argument can either accept <tt>TV_NTSC</tt> (or <tt>TV_224</tt> which does the same thing), or <tt>TV_PAL</tt> (or <tt>TV_240</tt>).<br>
					<br>
					The third argument specifies whether the 32X will have display priority over the Genesis display. The two valid arguments for this command are: <tt>PRIO_GEN</tt> or <tt>PRIO_32X</tt>.<br>
					<a href="#sega32xcommands">Back to the 32X Section</a><br>
					<br>
				<a name="command_marsvidrequest"></a><i>Command_MARSVIDREQUEST:</i><br>
					<i>Syntax:</i> <tt>MarsVidRequest</tt><br>
					<i>Description:</i> This command forces the video controller to accept commands from the Genesis. If you're using the 32X with BasiEgaXorz, and are controlling the display through the <tt>MarsVram</tt>, or <tt>MarsVramOw</tt>, and <tt>MarsCram</tt> arrays, then you have to use this command before you can start using these variables. If the SH2 Processors need the video controller to display stuff, then this command shouldn't be used.<br>
					<a href="#sega32xcommands">Back to the 32X Section</a><br>
					<br>
				<a name="var_marsvram"></a><i>MarsVram Array</i><br>
					<i>Description:</i> Reading, or writing to this array will directly access the drawing buffer of VRAM. The array can be accessed as a string/byte (<tt>MarsVram$(location)</tt>), or as an integer/16-bit word (<tt>MarsVram(location)</tt> or <tt>MarsVram%(location)</tt>), or as a long/32-bit-word (<tt>MarsVram&(location)</tt>). The size of VRAM is 262,144 bytes long.<br>
					<a href="#sega32xcommands">Back to the 32X Section</a><br>
					<br>
				<a name="var_marsvramow"></a><i>MarsVramOw Array</i><br>
					<i>Description:</i> This array direclty accesses the Overwrite portion of VRAM in the current drawing buffer. The array can be accessed as a string/byte (<tt>MarsVramOw$(location)</tt>), or as an integer/16-bit word (<tt>MarsVramOw(location)</tt> or <tt>MarsVramOw%(location)</tt>), or as a long/32-bit-word (<tt>MarsVramOw&(location)</tt>).<br>
					<a href="#sega32xcommands">Back to the 32X Section</a><br>
					<br>
				<a name="var_marscram"></a><i>MarsCram Array</i><br>
					<i>Description:</i> This array direclty accesses the Color RAM for the display controller. The array can be only accessed as an integer, or a 16 bit data type (<tt>MarsCram(location)</tt> or <tt>MarsCram%(location)</tt>). The CRAM has 256 different color entries, which is used for 8bpp mode, or RLE mode.<br>
					<a href="#sega32xcommands">Back to the 32X Section</a><br>
					<br>
			<a name="segacdconv"></a><b>Multi-Region Sega CD's</b><br>
				Okay, so you live in some 3rd world country, and you've made a Sega CD iso, and you want to play it on the real thing. BasiEgaXorz compiles iso's for use only in the USA, and won't work for some other country's Sega CD (or Mega CD) without some conversion. You can convert the iso image with MoD's ConvSCD to play your favorite BASIC game on your console. Homepage for it is here <a href="http://www.retrodev.com/convscd.html">http://www.retrodev.com/convscd.html</a>.<br>
				<br>
			<a name="Downloads"></a><b>Downloads</b><br>
				<tt>PLEASE READ THE <a href="#disclaimer">DISCLAIMER</a> BEFORE DOWNLOADING!</tt><br>
				<ul>
					<li><i>Main EXE Files</i>
					<ul>
						<li><a href="http://devster.monkeeh.com/sega/basiegaxorz/basiegaxorz137.exe"><i><b>Newest and Latest</b></i> - BasiEgaXorz v1.37 Using the ASMX Assembler</a>
						<li>BasiEgaXorz v1.28 (ASMX Assembler)</a>
						<li>BasiEgaXorz v1.23 (ASMX Assembler)
						<li>BasiEgaXorz v1.20 (old SNASM Assembler)
						<li>BasiEgaXorz v1.00 (old SNASM Assembler)
						<li>BasiEgaXorz v0.19 (old SNASM Assembler)
						<li>BasiEgaXorz v0.12 (old SNASM Assembler)
						<li>BasiEgaXorz v0.11 (old SNASM Assembler)
						<li>BasiEgaXorz v0.10 (old SNASM Assembler)
						<li>BasiEgaXorz v0.08 (old SNASM Assembler)
						<li>BasiEgaXorz v0.05 Beta (old SNASM Assembler)
						<li>BasiEgaXorz v0.04 (old SNASM Assembler)
						<li>BasiEgaXorz v0.02 (old SNASM Assembler)
						<li>BasiEgaXorz v0.01 (old SNASM Assembler)
					</ul>
				</ul>
			<a name="History"></a><b>History</b></p>
				<table border="1" cellpadding="0" cellspacing="2" width="100%">
				<tr>
					<td valign="top">1/3/2010<br>v1.37</td>
					<td valign="top">
						- This release is mainly for supporting RAM game compilation, and the LAKABAJO uploading system<br>
						- Added VRAM Initialization data instructions <tt>DATA, DATAINT, DATALONG, DATAFILE</tt><br>
						- Added the <tt>TILEORG</tt> istruction for VRAM Initialization<br>
						- Some more bug fixes and stability issues fixed<br>
					</td>
				</tr>
				<tr>
					<td valign="top">8/28/2008<br>v1.28</td>
					<td valign="top">
						- Fixed many bugs in assembly that ASMX made<br>
						- Fixed the <tt>INPUT</tt> and <tt>GETS</tt> commands to not break the heap inside functions<br>
						- Declaring a variable with an absolute address inside a function gives a compiler error now<br>
						- No more mot2bin.exe<br>
						- Doing a=a*-1 is functional again<br>
						- Compiling the fake_variables.bex example works<br>
						- The assemble function works again<br>
						- Bugs fixed with user-defined subs/functions breaking the heap<br>
						- A bug is fixed, where putting spaces in between parenthesis now works<br>
						- Fixed a bug with the DATALONG command<br>
						- Fixed a bug when entering strings with the INPUT command<br>
					</td>
				</tr>
				<tr>
					<td valign="top">2/20/2008<br>v1.23</td>
					<td valign="top">
						- BasiEgaXorz now uses the ASMX assembler!<br>
						- Not everything has been tested 100% with this version, so if something is broken, report the bug, and revert back to version 1.20!<br>
					</td>
				</tr>
				<tr>
					<td valign="top">2/11/2008<br>v1.20</td>
					<td valign="top">
						- Fixed the <tt>READ</tt>, and <tt>READINT</tt> commands when using long variables.<br>
						- Added support for arrays in the commands <tt>READ</tt>, <tt>READINT</tt>, <tt>READLONG</tt>, <tt>GETS</tt><br>
						- Fixed the <tt>GETS</tt> command to not declare integer or long variables that are very big<br>
						- Improved the <tt>INPUT</tt> command to be more BASIC like<br>
						- Added lower case letters to the <tt>INPUT</tt> command. Press the C button to switch between lower case letters and upper case<br>
						- Fixed a major bug with storing data with the <tt>DATA</tt> command.<br>
						- Fixed a bug with the <tt>Mid$</tt> function, which was broke in v1.00 of the compiler<br>
						- Fixed a compiler bug when opening a souce file that is in a completely different drive<br>
						TODO -&gt; Add the command <tt>DataStr</tt><br>
						- When a file has successfully compiled, the ending dialog will now show the time that was spent assembling the source with the SNASM assembler<br>
						- Fixed the VarPtr&() Function to work with the newer array data types<br>
						- Fixed expressions having the form: str$(val(a)+val(b)), str$(val(a)<<val(b)), and str$(val(a)>>val(b))<br>
						TODO -&gt; <tt>Print 1*65536</tt> is broken<br>
						- Fixed a major bug when declaring more than one sub or function<br>
						- Added an option to turn off the compilation summary at the end of compilation<br>
					</td>
				</tr>
				<tr>
					<td valign="top">12/25/2007<br>v1.00</td>
					<td valign="top">
						- The compiler will no longer give an error when using the same labels in inline assembly<br>
						- Added the ability to transform data within code into variables, also called &quot;Fake Variables&quot;<br>
						- Fixed bugs with <tt>LoadTiles</tt><br>
						- Fixed a bug with <tt>Datafile</tt> with even/odd addresses<br>
						- Fixed a bug when using &h0 as a constant<br>
						- Fixed a bug with <tt>EndCode&()</tt><br>
						- Fixed a bug with using integer addresses inside the peek functions<br>
						- Replaced the buttons on the toolbar with an "imagebox", so mscomctl.ocx is no longer required<br>
						- Fixed a bug that would crash the program intermitently if the text window is maximized<br>
						- Added an option to change the font foreground and background colors<br>
						- User can now define a custom location for variables declared with <tt>Dim</tt>. See Dim xxx AT xxx<br>
						- Fixed <tt>SETSCROLLMODE</tt> and <tt>SETSCROLLPLANE</tt> to now work with lower case settings<br>
						- Fixed minor bugs with using strings inside <tt>DATA</tt><br>
						- Added a feature to <tt>SLEEP</tt> and <tt>SLEEP2</tt> to change between ending the sleep command at the begining of the blank, or at the begining of drawing the video<br>
						- Fixed a bug with the HV Counter and running on real hardware - The M3 bit in VDP register mode #0 was set, so the counter is latched when a trigger on HL is executed. On real hardware, triggers upon reset are common.<br>
						- Fixed major problems with the heap reallocating itself during interrupters<br>
						- Fixed more major problems with the displaying characters and using interrupters<br>
						- Fixed a bug with the interrupters. If your interrupter ran for too long, the interrupter would be called back again<br>
						- The external interrupter will now latch the HV counter upon enabling the external interrupter. When its disabled, it will turn latching off<br>
						- Individual string characters can now be accessed from String arrays<br>
						- 32X Support! Read the 32X special commands, and functions<br>
						- Fixed a bug when you put <tt>ENDIF</tt> and there's no preceeding <tt>IF</tt>, the compiler would crash and burn<br>
						- First version to use SyNtAx CoLoRiNg!<br>
						- Fixed a bug when doing <tt>PRINT 90+78*(3+4)</tt><br>
						- A bug still exists, ie: <tt>PRINT 1+9999999999999</tt> or <tt>PRINT 2+9999999999999</tt>, and cannot be fixed. However, doing <tt>PRINT 9999999999999+1</tt> will work because the compiler will know in the begining that it will be dealing with long number data types!<br>
						- The compiler will no longer crash when there is an overflow in assigning large numbers, like <tt>long&=999999999999</tt><br>
						- Fixed a bug with <tt>MEMCPY</tt> and printing text<br>
						- Fixed a bug with <tt>HBLANK</tt> always staying at 0<br>
						- Added the functions <tt>VBLANKON()</tt> and <tt>HBLANKON()</tt><br>
						- Added the command <tt>WAITRASTER</tt> that will resume execution when the TV starts drawing on a specified line<br>
						- Fixed a bug with the compiler not finding snasm68k if the working directory was not in basiegaxorz<br>
						- Added a command <tt>VIDMODE</tt> to switch to either 40 cell mode (default) or 32 cell mode<br>
						- Added <tt>FontForeEntry</tt> and <tt>FontBackEntry</tt> to the list in the <tt>OPTIONS</tt> command<br>
						- Added <tt>OPTION Explicit</tt> to the option command, and can also be forced in the options menu<br>
						- Added the <tt>LOADFONT</tt> command<br>
						- Added more options to set the text drawing limits: <tt>TEXTHEIGHT</tt>, <tt>TEXTWIDTH</tt> and <tt>TEXTSTART</tt> options<br>
						- Forgot to halt the Z80 during <tt>CLS</tt> (clear screen uses video DMA)<br>
						- Custom functions and subs can now be declared<br>
						- Added <tt>OPTION CaseSense</tt> to the option command, and can also be forced in the options menu<br>
						- Added <tt>SELECT CASE</tt><br>
						- Added <tt>DO</tt> and <tt>LOOP</tt> loops<br>
						- Automatic Indentation and expanding tabs into spaces options have been added<br>
						- Made a new style options window since I couldn't cram more stuff in the old one<br>
						- Added the command <tt>DRAWTILESINC2</tt> that will draw tiles up->down, left->right<br>
						- Added a check to halt the cpu if a <tt>RETURN</tt> instruction is used without calling a subroutine<br>
						- The <tt>DIM</tt> statement can accept more than one variable in a list, eg: <tt>Dim a as long, b as integer, ....</tt>. Due to this, some things are broken. Can't do: <tt>Dim a as string, b as long, c as integer: Print "Hello!"</tt><br>
						- Limited user defined SUB/FUNCTION support<br>
						- Added the command <tt>FONTPAL</tt><br>
						- Fixed a bug with horizontal scrolling problems on real hardware<br>
						- Fixed a mistake in scrolling plane B verticle for both <tt>SCROLL</tt> and <tt>SCROLL2</tt><br>
						- Added the function <tt>READSCROLL()</tt> that will read the value of the scroll memory<br>
						- Fixed a bug with using the <tt>INPUT</tt> command with 6 button joypads on real hardware<br>
						- Fixed a bug in <tt>PRINT</tt> and <tt>PUTS</tt> that ignored seperators , and ; in multi-line commands<br>
						- Interrupters no longer save the data pointer, so data commands can be used in interrupters<br>
						- When a compiler error occurs, the editor cursor is moved to the line containing the error and the line is highlighted<br>
						- Fixed a bug with <tt>STR$()<tt> while using other string in the same expression before <tt>STR$()</tt> is evaluated<br>
						- Fixed a major bug with <tt>ELSEIF<tt> not being recognized as <tt>ELSEIF</tt>. This bug is different from the <tt>ELSEIF</tt> nesting bug, which might be fixed soon<br>
						- Fixed more bugs with the interrupters and heap allocating. The heap is now offset to an even address so assembly code can use word or long values in the heap, eg: command <tt>INPUT</tt><br>
						- Fixed bugs with instructions that require a long data type, and didn't accept any integer constants. Some of these commands were <tt>POKEINT, POKELONG,</tt> etc<br>
						- If there are no arguments in <tt>WAITPADUP</tt> then joypad 0 is assumed<br>
						- Finally fixed the <tt>ELSEIF</tt> nesting bug that has been ignored since v0.08<br>
						- The number of consecutive IF...THEN or ELSEIF...THEN has been increased from 20 to infinite<br>
						- Fixed the <tt>SHLINK</tt> command to work a little better. Before, the heap and stack were reset to the default, but now they're just changed depending on the condition of run-time<br>
						- <tt>SPRITEPOSX()</tt> and <tt>SPRITEPOSY()</tt> now truncate values over 512<br>
						- Added options to select different text priorities so text can now be overlayed on top of sprites<br>
						- Fixed Redo bug that would crash the program<br>
						- Fixed a bug with using comments (begining with ') after <tt>THEN</tt> keyword<br>
						- UNIX line feeds in source files supported<br>
						- Added the commands <tt>GLOBAL</tt> and <tt>LOCAL</tt> to assign scopes for variables used in user defined subs and functions<br>
						- Added command <tt>WRITEP</tt> and the function <tt>READP</tt> to read and write to variables located in an external 8-bit ram<br>
						- Fixed some stuff in 32x headers so that roms can now run on the Gens emulator<br>
						- Fixed a major bug with the Genesis requesting frame buffer access from the 32x (now roms can run on real hardware!)<br>
						- Fixed a minor GUI bug that occurs when the user quits the application with two documents opened, with one docuemtn that has been modified that has lost its focus. Clicking YES on the form that asks if you wish to save will make the form keep popping up infinitely<br>
						- Now you don't need to use [AND], [XOR], or [OR] to specify logical operations =D! Just use the operators without the brackets, just like in regular basic, eg: <tt>a=&h1234 and &h0ff0</tt>. The NOT operator isn't like this yet because there are problems with ordering. [AND], [OR], and [XOR] with the brackets will still work for compatibility with old sources<br>
						- Fixed a bug with function <tt>LEN()</tt> that can mess up the heap<br>
						- Added more arguments to the <tt>INK</tt> command that will draw text and tiles in other different ways. Also added the <tt>COLOR</tt> command, that will do the exact same thing as <tt>INK</tt><br>
						- When booting programs, the video draw mode will be set appropriately to PAL or NTSC so programmers don't need to set this themselves<br>
						- Fixed a bug with <tt>SCROLL2 LEFT</tt> and <tt>SCROLL2 DOWN</tt><br>
						- Fixed some more bugs with the <tt>INPUT</tt> command, once again<br>
						- Fixed a bug, again, with the <tt>PRINT</tt> command that misinterprets semi-colons. For example, this works now like it's suppose to: <tt>PRINT "hi": INK 1: print "YO"</tt><br>
						- If the third argument in <tt>DRAWTILE</tt> (the argument that asks for a Y coordinate) is omited, then Y is 0. The X coordinate can range from 0 to 16383 for planes that are 128x128 large<br>
						- Fixed a buncha argument parsing bugs with some commands<br>
						- Added more Sega CD specific commands that deal with external data loading<br>
						- <tt>LOADSCD</tt> can now copy data from a CD to variables, or directly to VRAM<br>
						- Multi-dimensional array support has now been added, even though I said it was impossible!<br>
						- Improved the way string arrays are handled<br>
						- Changed commands <tt>SLEEP, SLEEP2, VALT, HALT, DALT, HBLANKON(), VBLANKON()</tt> to now act upon the HV counter, not the VDP status register<br>
						- Fixed a bug in the command <tt>TVSET</tt><br>
						- Fixed a bug with hexidecimal numbers. Anything like &hFFFF won't turn into a negative number.<br>						- String constants in <tt>DATA</tt> statements no longer need to be zero-terminated. The compiler is still backwards compatible with strings that were zero-terminated by the programmer.<br>
						- There can now be ten files in the recently opened list instead of just one<br>
						- Right click on the source editor now works again<br>
						- Fixed some bugs that prevented Sega CD ISOs from playing on real hardware<br>
					</td>
				</tr>
				<tr>
					<td valign="top">6/23/2004<br>v0.19</td>
					<td valign="top">
						- Added the ability to create faster subs and functions using just plain assembly. The compiler will not place any slow, bloated code for ASM SUBS or ASM FUNCTIONS.<br>
						- Added the endcode data label<br>
						- Fixed a bug when using argunerics directly on a function, where the future expressions would not be interpreted. Eg: <tt>a=joypad().7+1</tt>, the +1 would be missed.<br>
						- Finally, other basic programs can be included into other basic programs using the <tt>INCLUDE</tt> command. There's a catch though, included can only be nested once, the begining line label check doed not work, you cannot add multiple statements on the <tt>INCLUDE</tt> command, and it is still very buggy and will be buggy for a long time. Including programs was a hard to do with the compiler since everything is compiled linearly.<br>
						- More IDE junk: In the options dialog, an emulator and tile editor can be searched for with an open dialog box<br>
						- Added an Open Recent menu<br>
						- Included a window that will display all Sega CD programs added with the <tt>ADDSCD</tt> command for Sega CD Boot ISOs. It shows the filename, and its assigned sector. This will be helpful for keeping track of sector numbers.
						- Added the support for in-line constants with the # symbol<br>
						- Improvements were made to assiging labels to data (data labels)<br>
						- Fixed yet another bug with <tt>DRAWTILES</tt> with the Tiles VRAM Offset argument, where it actually didn't work<br>
						- Added a new command, <tt>DRAWTILESINC</tt> which doesn't use any data labels, but draws tiles in an incrament fasion, eg: specify it to start at tile 128, and it will draw all tiles from 128 to etc<br>
						- Added a new commnad, <tt>DRAWTILESOVR</tt> which acts like <tt>DRAWTILES</tt>, but tiles marked 0 will not be drawn, preserving the background<br>
						- Fixed the clr.l d1 bug with the command <tt>DRAWTILES</tt> and <tt>DRAWTILE</tt><br>
						- Added the functions <tt>POSX, POSY, CURINK</tt> to determine the cursor's position, and the current ink color<br>
						- Added the function <tt>READTILE</tt><br>
						- The compiler adds a label to each <tt>ASM</tt> nested statements, and to libraries so the user can use @label and any label name for labels<br>
						- All 4 PSG channels are set to mute in the start up<br>
						- Fixed the Soft Reset bug on real hardware. The software would always check the status of the HV counter on startup, and would infinitely loop if it wasn't in a specific range - pretty nifty =D<br>
						- Some GUI optimizations here and there<br>
						- Fixed a bug when the last open document was closed, some buttons would dissapear, and some buttons would crash the program<br>
						- Splash screen (actually the about screen) added, and is shown when a new compiler version is executed for the first time<br>
						- When multiple documents are in the command line, the IDE will open them all in multiple windows<br>
						- The External TH Interrupter on the joypad port is now supported<br>
						- The command <tt>LoadTiles</tt> is now 3 times faster! Note: Speed is measured only when the screen is disabled. With the old routine, it would take 1.08 minutes to load 1024 sets of 1024 tiles (Equals 32mb). With the new routine, it took 0.37 minutes.<br>
						- The functions <tt>HFlipTile, VFlipTile, RotateTile, Priority, and Palette</tt> have been added to customize drawing tiles<br>
						- Some Editing Enhancements: Find, Find Next, Search and Replace, Insert Date+Time, and Go To Line<br>
						- Fixed a bug with the <tt>Dim</tt> command that allocated 2 bytes to long variables<br>
						- Fixed a bug with <tt>ReadLong</tt> that allocated 2 bytes to long variables that haven't been created<br>
						- Added the commands <tt>FastTileCopy</tt> and <tt>MemCopy</tt> to do some low-level, high-speed memory copying<br>
						- <, >, <=, >=, and <> string comparisons works now. When a string is compared to another string, the destination value will be an integer.<br>
						- The function <tt>UnitType</tt> added to determine whether the machine is a domestic, or overseas unit<br>
						- The function <tt>TVType</tt> added to determine whether the machine is NTSC, or PAL<br>
						- The function <tt>VDPRAMRead()</tt> and the command <tt>VDPRAMWrite</tt> were added to read/write directly to the VDP RAM<br>
						- The functions <tt>Read$, Read, ReadINT(), and ReadLONG&()</tt> were created, so execution time is faster if data doesn't need to be read into a variable, but passed into an expression<br>
						- <tt>ReOrgCode</tt> option added to change the code address for Sega CD Porgrams<br>
						- <tt>ReOrgVars</tt> option added to change the next variables address to tack on more RAM storage for Sega CD games<br> 
						- <tt>StartCode&</tt> function added to give the first byte of compiled code<br>
						- <tt>EndCode&</tt> function added to give the last byte of compiled code<br>
						- External RAM Support for variables<br>
						- .BEX file associations can now be done within the IDE<br>
						- The expression system now handles parenthesis, eg: <tt>a=4+((((7*2)*(1+2))*(2*2))+5)</tt> works<br>
						- Assembly code is automatically optimized<br>
						- The command <tt>FAKE</tt> has been added to virtually make variables into fake data labels for use with <tt>RELOAD, READ, WRITE</tt>, and tile/palette loading commands<br>
						- Genesis roms can now be compiled for PAL machines with the command <tt>TVSET</tt><br>
						- <tt>Regmove.x</tt> can now use immediate values for sourcing arguments<br>
						- Fixed a bug with <tt>LOADTILES</tt>. Now it clears register d1 before use.<br>
						- Fixed a bug in the <tt>INPUT</tt> command when the screen scrolls down<br>
						- Added font and tab options to the IDE<br>
						- BasiEgaXorz low level routine speedups: Faster displaying of strings in PRINT,<br>
					</td>
				</tr>
				<tr>
					<td valign="top">4/21/2004<br>v0.12</td>
					<td valign="top">
						- Fixed a bug in the expression handling when you do <tt>if c then</tt><br>
						- Fixed a bug in the bit argunerics<br>
						- Added a new command <tt>Sleep2</tt> which delays on each horizontal blank instead of verticle blanks<br>
						- Added a new function: <tt>LBLPtr&()</tt> which gets the address of a data label<br>
						- Label in the <tt>Palettes</tt> command can now have an offset<br>
						- Label in the <tt>DrawTiles</tt> command can now have an offset<br>
						- INPUT and GETS commands can now handle integer and long data types<br>
						- Fixed a bug when a cpu exception occurs, or when a breakpoint is reached<br>
						- Finally added long (4 byte) multiplication, division, and modulo<br>
						- Added the instruction <tt>RegMove.l, RegMove.w, RegMove.b</tt> to get assembly registers into variable, or vice versa<br>
						- Fixed a bug where if For, If, Dim, or Let were Uppercase, the compiler wouldn't identify it<br>
						- Added an option to run the the Compiled ROM/ISO in an emulator after it is compiled<br>
						- Changed the documentation: switched the Height and Width arguments around for the AddSprite function<br>
						- Added the Not() and Not&() Functions<br>
						- Can now open files from the command line, and the program can have more than one instance now<br>
						- Minimize bug fixed<br>
						- Fixed a bug in the Randmize command<br>
						- If <tt>While 1</tt> is used, then the compiler will jump directly back the commands after the <tt>While</tt> command when a <tt>Wend</tt> command is encounterd. This makes <tt>While 1</tt> loops very fast without having to solve expressions, or jump on a condition, etc<br>
						- Added the <tt>Exit While</tt> and <tt>Exit For</tt> commands<br>
						- Added the <tt>Continue While</tt> and <tt>Continue For</tt> commands<br>
						- Added the string functions: <tt>ChrW$</tt> and <tt>ChrL$</tt><br>
						- Added the functions: <tt>Asc</tt> and <tt>AscW</tt> and <tt>AscL&</tt><br>
					</td>
				</tr>
				<tr>
					<td valign="top">4/11/2004<br>v0.11</td>
					<td valign="top">
						- Now added the Let command<br>
						- When the Open/Save dialog is opened for the first time, its default directory will be the compiler's directory<br>
						- The Library command can now handle long file names<br>
						- Added the command: Incasm, which is like the Library command, except it doesn't search the "slibrary" directory for the assembler file. It either searches the project's own directory, or the compiler's directory if the source code is untitled<br>
						- Forgot to add the Ignore SCD Commands option. It is now added<br>
						- Fixed a bug with the Sega CD commands that froze the main CPU<br>
						- Fixed the LoadSCD command to disable interrupters when loading a cluster<br>
						- Fixed the text DMA commands (CLS, Line Feeds) to work for the different planes<br>
						- Fixed the clear length in CLS<br>
						- Big sprite commands added<br>
						- Fixed DataFile to recognize labels not on the same line<br>
						- Now aligns DataFile to EVEN bounds<br>
						- For the 4th time, the FOR...next loop has been recoded, now even faster<br>
						<b>- Compiler speed increase =D - by 200 times. The compiler doesn't use VB's buffers to store the compiled assembly file no more =). This bypasses all of VB's overhead, and makes it compile 100,000 number of lines of <tt>print "hi"</tt> in 48 seconds on a 1.2 ghz computer running number line checks.</b><br>
						- For the VB users, i created an option to save BASIC files with a .bex extension<br>
						- Fixed a bug where if you go <tt>print "wassup":a=a+1</tt>, it messes up<br>
						- Added a feature to the ASM command, where if you leave the second argument blank, the lines after ASM are the assembly source, and it end when it encounters an END ASM command.<br>
						- Added the Gets command, and changed the Input command around to act like the real basic Input command<br>
					</td>
				</tr>
				<tr>
					<td valign="top">4/5/2004<br>v0.10</td>
					<td valign="top">
						- Added a color converter for color codes<br>
						- Data labels don't need to be on the same line as the data statement now. the compiler takes the last label encountered, and makes that the data label<br>
						- No more make.bat or make.pif files =D!<br>
						- No more rich text box :D!!! lots+lots of features with the ide were added/fixed because of this =P (too many to list here)<br>
						- Added more options for naming, and directories<br>
						- Sega CD audio playback commands added<br>
						- Datafile command now searches the project directory for the data file. If a project is untitled, the command will search the path of the compiler for the file. File names can no be longer than 8 characters (long file names)<br>
						- Drawing to different scroll planes, and to the window is now implemented for both text and graphics<br>
						- Added commands to format the window<br>
						- Updated the scroll command to do more things that take scrolling to the Genny's hardware capabilities<br>
						- Multiple Sega CD programs can be stored on one boot iso now<br>
						- Text+Graphics commands updated to change displaying properties<br>
						- Added a Puts command which displays text a whole lot faster, but more parameters are required for this<br>
						- Freed up 256 bytes of RAM<br>
						- List of New Commands: <tt>BGColor, FreeAllSprites, SetTextPlane, SetGfxPlane, WindowProp, Disable Window, Puts, Scroll2, SetScrollMode, SetScrollPlane, Write, WriteInt, WriteLong, AddSCD, LoadSCD, CDPlay, CDPlay2, CDStop </tt><br>
						- More options for the option command: <tt>Option SegaCD, Option SegaCD Program, Option Cartridge</tt> - which overwrites the setting in the option menu to change the output file type<br>
				</tr>
				<tr>
					<td valign="top">3/2/2004<br>v0.09</td>
					<td valign="top">
						- Mostly fixes to the Master Routines:<br>
						- Fixed waitpadup. sometimes it messed up w/o detecting any key<br>
						- Fixed readint statement. putting in a variable causes an error<br>
						- Fixed drawtile. the x and y arguments were backwards<br>
						- Fixed chr$() function. the function never added a null to the heap<br>
						- Fixed data commands. the data command alligned all data to even bounds at the end of the data. if two data statements were one after the other, invalid data would appear if the first data statement was odd. this has been fixed by adding even allignments to the begining of all dataint and datalong commands, instead of data.<br>
						- Fixed data commands to accept &h as a hex number<br>
						- Fixed the immediate addition/subtraction operators to properly add long veriables. Before, it use to add 65536<br>
						- Redid the sprite system. Before, sprites were added by using the linking method of the Sega's hardware. Now, the routines don't even use linking, just straight 0-79. There were lots of bugs with the linking system.<br>
						- Sprites can now all be wiped out with a command<br>
						- When an interrupt occurs, 2048 bytes are added to the heap, which is gonna fix some interrupter bugs conflicting with surprise memory overwrites. Not very useful to know for beginers, but I thought I'd put it here for completeness =D<br>
						- Fixed traps and breakpoints to enable the screen if it was disabled<br>
					</td>
				</tr>
				<tr>
					<td valign="top">2/29/2004<br>v0.08</td>
					<td valign="top">
						- Tab spaces are recognized as regular spaces<br>
						- Added a memory map viewer for variables in the gui for debugging<br>
						- Compilation of Sega CD isos supported (currently only 128k games)<br>
						- Compilation supported for Mask of Destiney's Transfer Suite<br>
						- Many many many fixes and optimizations to the expression engine and argument parser<br>
						- Added I/O functions poke and peek and their long/word subcommands<br>
						- Added a button on the toolbar to easily call the tile editor (custom sgtd.exe for basiegaxorz tiler will be released later)<br>
						- Added options for editor colors<br>
						- Interrupter handlers improved<br>
						- Performance improvements for the For...Next loop<br>
						- Added support for long 32 bit variables<br>
						- Random function finally added<br>
						- The horizontal blank interrupter is now supported<br>
						- Bug fixes to the shlink command - but still, just use sparingly, especially for testing games on the real system<br>
						- Cursor postion thing fixed in the gui<br>
						- DMA functions fixed from beta 0.05<br>
						- Made a much better joypad function. 6-button controller supported<br>
						- Hex$(), Chr$(), Bin$(), Mid$(), String$(), Left$(), Right$(), and Len functions added for string parsing<br>
						- Bit argunerics added<br>
						- Option command added for replacing the title header, and also to define Sega CD dedicated games, and default string size<br>
						- ShiftSprite added to relatively move the sprite without keeping track of its position<br>
						- Background plane scrolling added<br>
						- The &quot;:&quot; technique added (eg. the &quot;:&quot; in <tt>ink 3: print &quot;wassup&quot;</tt>)<br>
						- Arithmetic shift added<br>
						- Negative number support for decimal numbers<br>
						- Support for hexidecimal arguments eg. &amp;h1234<br>
						- And, Or, Xor operators added<br>
						- ElseIf finally added<br>
						- Sprite positions can be read with function SpritePosX or SpritePosY<br>
						- Single dimentsion arrays added only for Integer and Long data types<br>
						- 16 bit and 32 bit wide data supported with DataInt and DataLong, and for reading, ReadInt and ReadLong<br>
						- RGB function added<br>
						- Addsprite command is now a function<br>
						- Brighten and Darken commands added for fading in or out palettes<br>
						- Increment and Decrement operations added<br>
						- Added sound commands for the PSG for making sound effects (Sound, SoundVol)<br>
						- User defined assembly routines support added for the more advanced programmers<br>
						- VarPrt& function added<br>
						- Display can now be turned on/off for faster tile data loading using the Disable/Enable commands<br>
						- Halt, Valt, and Dalt commands added to wait for the horizontal/verticle blank before anything else is executed<br>
						- TVScanX() and TVScanY() functions added to read the HV Counter<br>
						- Palettes command added for adding multiple colors<br>
						- Input command added to easily get user input<br>
						- Str$ and Val functions implemented<br>
						- Assembly headers are built into the exe again<br>
						- Whenever an unexpected error occurs when assembling, an error log is created and displayed for debugging<br>
						- Fixed BasiEgaXorz to run on Windows 95 with a 486 running at 66 mhz =D<br>
						- Added a Trap command to act as a breakpoint for debugging<br>
						- Added error messages for CPU errors (eg. address error/illegal instruction/divide by zero) - these errors can not be recovered in run-time<br>
						- Rem and ' Comments supported<br>
						- Added a button to assemble a plain assembly file to binary<br>
						- A last quickie WaitPadUp Command added<br>
						- Fixed a string-function bug (eg. doing a$="asdf"+chr$(12))<br>
						- Fixed a bug with using an apostrophe in a string constant (eg: "what's up doc")<br>
						- Fixed a bug that messed up carriage returns in the editor<br>
						<br>
						- A total of ~50 additions/fixes/changes :-)!!!</td>
				</tr>
				<tr>
					<td valign="top">1/12/2004<br>v0.05 beta</td>
					<td>
						- This update is for more commands, no optimizations/fixes have been done yet<br>
						- Graphics commands are now implemented<br>
						- Verticle blank interrupter implemented<br>
						- Colors commands and stuff added<br>
						- DMA functions are broke, use version 0.04</td>
				</tr>
				<tr>
					<td valign="top">1/9/2004<br>v0.04</td>
					<td>
						- Argument routine is redone (means that lots of things can be done now)<br>
						- Statements seperated by a colon now works<br>
						- More statements added: Data, Datafile, Read, Reload, While...Wend, End (Getting ready for graphics and sprites and tiles now and interrupts)<br>
						- There is now an option to disable the begining label check, and the proceeding label checks. If you're not keeping track of your labels, and you have this on, your program may refuse to compile. This option is for compiling larger programs quickly. If you have a program &gt; 2000 lines, it'd be good to turn this on. If not, you don't need the option on.<br>
						- Comments added<br>
						- More tiny stupid bugs fixed<br>
						- Compiler optimized heavily<br>
						- Added a nicer font and changed to a better color =)</td>
				</tr>
				<tr>
					<td valign="top">1/6/2004<br>v0.02</td>
					<td>
						- Added Support for Functions to the expression routine<br>
						- Two character operators added (&gt;=, &lt;=, &lt;&gt;)<br>
						- Fixed stupid bug with pasting and saving<br>
						- Better shell() routine<br>
						- Compile time is faster (Can compile 3000 lines of &quot;print 1+2-3&quot; in 209 secs)<br>
						- Can compare strings now (Only = can be used for now)<br>
						- basichdr.s is not built into the compiler. The header can be modified if you want to add your own font for now, or change the colors, etc.</td>
				</tr>
				<tr>
					<td valign="top">12/25/2003<br>v0.01</td>
					<td>
						- Released first public release, version 0.01. Lots of things are unsupported, for I need to spend more time on the compiler (only took 4 days from now =D) and was released early for Christmas.</td>
				</tr>
			</table>
			<br>
			<a name="Bugs"></a><b>Bugs</b><br>
				The whole program is a bug. Report bugs at the forum or something, or email me, and i'll try to fulfil your request =). Look down at contacts.<br>
				<br>
				KNOWN QUIRKS:<br>
				- In the IDE, a TAB is recognized as one character, so the column count is messed up with tabs<br>
				- Code with the following style won't work: <tt>Print 1+65536</tt> or <tt>Print 1*70000</tt> or <tt>print 1*r&</tt>. To fix this, you would have to do the following to make the compiler recognize the expression as a long data type: <tt>Print 70000*1</tt>.
				<br>
			<a name="Contacts"></a><b>Contacts</b><br>
				Need extra help? Go post in the forums, 99.9% of the time I myself will answer any question<br>
				Forums: <a href="http://devster.proboards22.com/">http://devster.proboards22.com/</a> - You do not need to register to post in the BasiEgaXorz Support Forum if you don't want to. Just post as a guest.<br>
				Website: <a href="http://devster.monkeeh.com">DevSter Speicialties</a><br>
				My Email (i don't read my e-mail =P, it'd be better to PM me something on the forums): jonorm123@hotmail.com<br>
				<br>
			<a name="Credits"></a><b>Credits</b><br>
				Driector, Manager, Programmer, Graphics Designer, More Programming Stuff, Everything else - Me<br>
				The dude that made Snasm68k - you rock man<br>
				Mask of Destiney - Props go to him for the Sega CD tech stuff<br>
				Tomman - First one to report bugs =)<br>
				<br>
			<a name="disclaimer"></a><b>DISCLAIMER</b><br>
				BasiEgaXorz is Copyright 2003-2008 by Joseph Norman. This software is provided as freeware. This software is provided as-is, and you may not distribute it to the masses (ex: on your web site), sell this software, or modify it without my written consent. I do not take any responsibility for things you mess up. READ the disclaimer below for the 200 word version of this.<br>
				<br>
				YOU SHOULD CAREFULLY READ THE FOLLOWING USER AGREEMENT AND DISCLAIMER OF WARRANTIES AND LIABILITIES ("AGREEMENT AND DISCLAIMER") BEFORE DOWNLOADING BASIEGAXORZ. DOWNLOADING OR USING THIS SOFTWARE INDICATES YOUR ACCEPTANCE OF THIS AGREEMENT AND DISCLAIMER. IF YOU DO NOT AGREE WITH THIS AGREEMENT AND DISCLAIMER, YOU MAY NOT DOWNLOAD THIS SOFTWARE, AND YOU MUST IMMEDIATELY DELETE ALL COPIES OF THE SOFTWARE IN YOUR POSSESSION.<br>
				<br>
				User Agreement: You may not rent, lease, or assign this software. You may not decompile, disassemble, or modify this software. You may not transfer, distribute or bulk-distribute this product without Dester's express written permission. You assume responsibility for the use of this software to achieve your intended results, and for the installation, use, and results of using this software.<br>
				<br>
				Disclaimer of Warranty and Liability: DevSter does not warrant that this software will download correctly or that it will install correctly on your machine. DevSter does not warrant that the functions contained in the software will meet your requirements or that the operation of the software will be uninterrupted or error-free or that any software defects will be corrected. This product is provided solely on an "as-is" basis, and nor DevSter make any claim as to fitness for a particular purpose whatsoever. To the maximum extent permitted by law, DevSter disclaims all warranties, expressed or implied, including but not limited to, implied warranties of merchantability or fitness for a particular purpose.<br>
				<br>
				DevSter has no liabilities for consequential damages. In no event shall DevSter be liable for any damages whatsoever (including, but not limited to, damages for loss of business profits, business interruption, loss of business information, or any other pecuniary loss) arising out of the use of, or out of the inability to use, this product, even if DevSter has been advised of the possibility of such damages. DevSter reserves the right to modify or update any part of this Agreement and Disclaimer without prior notification.<br>
				<br>
		</div>
		<br>
		<br>
		<div align="right"><i>
			BasiEgaXorz Copyright Joseph Norman, 2003-2010<br>
			Sega Genesis is Copyrighted by Sega<br>
		</i></div>
	</body>
</html>